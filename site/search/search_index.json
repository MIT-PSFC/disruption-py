{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DisruptionPy","text":"<p>A Python package for plasma disruption analysis and prediction. </p>"},{"location":"#background","title":"Background","text":"<p>A key element of plasma control systems (PCS) in tokamak reactors is the prediction and avoidance of disruptions, sudden losses of the thermal and magnetic energy stored within the plasma that can occur when tokamaks operate near regions of plasma instability or because of system malfunctions. The energy released during  disruptions can cause severe damage to plasma-facing components, limiting experimental operation or even the device lifetime. This poses a serious challenge to next-step fusion experiments such as SPARC, which will have to operate near some of the limits of plasma stability to achieve its intended performance and will do so at for long and frequent intervals. Previous work has shown the promise of machine-learning (ML) algorithms for disruption prediction in both DIII-D and EAST -- the Experimental Advanced Superconducting Tokamak in China -- PCS. This is also due to the fact that fusion science currently lacks first-principle, theoretical solutions to fully predict and avoid disruptions. </p> <p>DisruptionPy is an open-source python package for training, updating, and evaluating algorithms for disruption prediction and avoidance that can be applied to DIII-D and EAST PCSs and inform SPARC disruption management strategies. It is being a developed and maintained by MIT EECS Meng student as part of his thesis \"A machine-learning driven framework for plasma disruption detection in tokamaks.\"</p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>disruption_py # Source code\ndocs # Mkdocs generated documentation\niris_requirements # requirements.txt for D3D iris cluster\nmatlab # Original matlab scripts\nml_log # Tracking thesis experiments \nnotebooks # Example notebooks for analysis and visualization\nrequirements # Requirements for locally installed environment\nscripts # Scripts for various disruption_py supported workflows\n</code></pre>"},{"location":"#references-and-resources","title":"References and Resources","text":"<ul> <li>Design Document</li> <li>Thesis Proposal</li> <li>Roadmap(TODO) </li> </ul>"},{"location":"generate_datasets/","title":"Generating Datasets","text":"<p>generate_datasets.py provides disruption_py users the ability to easily generate dataset files for any subset of implemented shot parameters. Parameters can either be grabbed from the relevant SQL database, calculated directly from the original MDSPlus data, or use both where the user can define the default and fallback behavior.  * NOTE: Currently, disruption_py can only guarantee that the timebase for each shot as well as parameters grabbed directly from MDSPlus will be correct. Any parameters calculated based on MDSPlus data may contain notable discrepancies from the SQL database. </p>"},{"location":"generate_datasets/#example-usage","title":"Example Usage","text":""},{"location":"generate_datasets/#generate-a-dataset-using-shots-in-sql-table","title":"Generate a dataset using shots in SQL table","text":"<pre><code>python3 generate_datasets.py --data_source=1 --shotlist=./data/example_shotlist.txt --efit_tree=efit01\n</code></pre>"},{"location":"generate_datasets/#generate-a-dataset-directly-from-mdsplus-data","title":"Generate a dataset directly from MDSPlus data","text":"<pre><code>python3 generate_datasets.py --data_source=3 --shotlist=./data/example_shotlist.txt --efit_tree=efit01\n</code></pre>"},{"location":"generate_datasets/#argument-list","title":"Argument List","text":"Optional arguments Description -h, --help show argparser help message and exit --shotlist SHOTLIST Path to file specifying shotlist --feature_cols FEATURE_COLS Either a file or comma-separated list of desired feature columns --output_dir OUTPUT_DIR Path to generated data. --timebase_signal TIMEBASE_SIGNAL Signal whose timebase will be used as the unifying timebase of the dataset. (Current choices are 'ip', 'disruption_timebase', and 'flattop') --efit_tree EFIT_TREE Name of efit tree to use for each shot. If left as None, the script will use the get_efit_tree method in database.py. --data_source {0,1,2,3} 0: Default to SQL database then MDSPlus.\\n1: Default to MDSPlus then SQL database.\\n2: SQL database only.\\n3: MDSPlus only. --unique_id UNIQUE_ID Unique identifier for the dataset. Used to name the output files. --log LOG By default, generate_datasets will log to commandline but if this argument is true it will log to a file in the output directory --log_level {0,1,2,3,4,5} Notset:0 Debug:1,Info:2,Warning:3,Error:4 Critical:5"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#locally","title":"Locally","text":"<p>TBD</p>"},{"location":"installation/#on-specfic-clusters","title":"On Specfic Clusters","text":""},{"location":"installation/#cmod","title":"CMOD:","text":"<p>The following command will install the disruption warning package locally in develop mode. In develop mode, changes to the directory used for installation will be reflected in the installed package.   </p> <pre><code>pip3 install --user -e /home/hmturner/disruption_py # No --user needed if installing in a virtual env\n</code></pre>"},{"location":"installation/#d3d","title":"D3D:","text":"<p>First we need to load the proper modules:</p> <pre><code>module load python/3\nmodule unload gcc-4.9.2\nmodule load gcc7/default\n</code></pre> <p>(OPTIONAL) Create and activate a new virtual env. I named it disruptions but feel free to name it whatever you want. </p> <pre><code>python3 -m venv disruptions\nsource disruptions/bin/activate\n</code></pre> <p>Next, because of the age of the iris cluster, we install a special list of dependency packages and their versions.</p> <pre><code>pip3 install -r iris_requirements.txt\n</code></pre> <p>Finally, we'll install the package. The following command will install the disruption warning package locally in develop mode. In develop mode, changes to the directory used for installation will be reflected in the installed package.   </p> <pre><code>pip3 install --user -e /fusion/projects/disruption_warning/disruption-warning-db-workflow/\n</code></pre> <p>NOTE(not true just yet): The directory for installation is not the one I use for daily development and I will only push changes to it that have been tested. </p>"},{"location":"shots-reference/","title":"Shot","text":"<p>Class for a single shot.</p>"},{"location":"shots-reference/#disruption_py.shots.Shot--parameters","title":"Parameters","text":"int <p>Shot number.</p> pandas.DataFrame, optional <p>Data for the shot. If not provided, an empty DataFrame will be created.</p>"},{"location":"shots-reference/#disruption_py.shots.Shot--attributes","title":"Attributes","text":"pandas.DataFrame <p>Data for the shot.</p> MDSplus.Connection <p>MDSplus connection to the shot.</p> MDSplus.Tree <p>MDSplus tree for the shot.</p> logging.Logger <p>Logger for the shot.</p> int <p>Shot number.</p> dict <p>Metadata for the shot.</p> Source code in <code>disruption_py\\shots\\shot.py</code> <pre><code>class Shot:\n\"\"\"\n    Class for a single shot.\n\n    Parameters\n    ----------\n    shot_id : int\n        Shot number.\n    data : pandas.DataFrame, optional\n        Data for the shot. If not provided, an empty DataFrame will be created.\n\n    Attributes\n    ----------\n    data : pandas.DataFrame\n        Data for the shot.\n    conn : MDSplus.Connection\n        MDSplus connection to the shot.\n    tree : MDSplus.Tree\n        MDSplus tree for the shot.\n    logger : logging.Logger\n        Logger for the shot.\n    _shot_id : int\n        Shot number.\n    _metadata : dict\n        Metadata for the shot.\n    \"\"\"\n\n    logger = logging.getLogger('disruption_py')\n\n    def __init__(self, shot_id, data=None):\n        self._shot_id = int(shot_id)\n        try:\n            commit_hash = subprocess.check_output(\n                [\"git\", \"describe\", \"--always\"]).strip()\n        except Exception as e:\n            commit_hash = 'Unknown'\n        if self.logger.level == logging.NOTSET:\n            self.logger.setLevel(logging.INFO)\n        assert self.logger.level != logging.NOTSET, \"Logger level is NOTSET\"\n        if not self.logger.hasHandlers():\n            self.logger.addHandler(logging.StreamHandler())\n        assert self.logger.hasHandlers(), \"Logger has no handlers\"\n        self._metadata = {\n            'labels': {},\n            'commit_hash': commit_hash,\n            'timestep': {},\n            'duration': {},\n            'description': \"\",\n            'disrupted': 100  # TODO: Fix\n        }\n        self.data = data\n        if data is None:\n            self.data = pd.DataFrame()\n\n    @staticmethod\n    def get_signal(id, signal_name, conn, interpolate=True, interpolation_timebase=None):\n        if isinstance(conn, MDSplus.Tree):\n            signal_record = conn.getNode(signal_name).getData()\n            signal = signal_record.data()\n            orig_timebase = signal_record.dim_of(0)\n        elif isinstance(conn, MDSplus.Connection):\n            signal = conn.get(signal_name).data()\n            orig_timebase = conn.get(\n                f\"dim_of({signal_name})\").data()/1.e3  # [ms] -&gt; [s]\n        else:\n            raise TypeError(\n                \"conn must be either MDSplus.Connection or MDSplus.Tree\")\n        if len(orig_timebase) &lt; 2:\n            raise ValueError(\n                f\"Timebase for {signal_name} is too short ({len(orig_timebase)})\")\n        if interpolate:\n            if interpolation_timebase is None:\n                raise ValueError(\n                    \"interpolation_timebase must be provided if interpolate is True\")\n            signal = interp1(orig_timebase, signal, interpolation_timebase)\n        return signal, orig_timebase\n\n    def _get_signal(self, signal_name, signal_conn=None, interpolate=True, interpolation_timebase=None):\n\"\"\"Get a signal from MDSplus.\n\n        Parameters\n        ----------\n        signal_name : str\n            Name of the signal in MDSplus.\n        signal_conn : MDSplus.Connection, optional\n            MDSplus connection to get the signal from. If not provided, the default\n            connection will be used.\n        interpolate : bool, optional\n            Whether to interpolate the signal onto the timebase of the experiment.\n            If True, the signal will be interpolated from the timebase of the signal\n            in MDSplus to the timebase of the experiment.\n        interpolation_timebase : array_like, optional\n            Timebase to interpolate the signal to. If not provided, the current timebase of\n            the Shot object will be used.\n\n        Returns\n        -------\n        signal : array_like\n            Signal from MDSplus.\n        orig_timebase : array_like\n            Timebase of the signal in MDSplus.\n\n        \"\"\"\n        if signal_conn is None:\n            signal_conn = self.conn\n        if interpolation_timebase is None and interpolate:\n            interpolation_timebase = self._times\n        return type(self).get_signal(self._shot_id, signal_name, signal_conn, interpolate, interpolation_timebase)\n</code></pre>"},{"location":"shots-reference/#alcator-c-mod","title":"Alcator C-Mod","text":"<p>         Bases: <code>Shot</code></p> <p>Class for a single CMod shot.</p> Source code in <code>disruption_py\\shots\\cmod_shot.py</code> <pre><code>class CModShot(Shot):\n\"\"\"\n    Class for a single CMod shot.\n\n    \"\"\"\n    efit_vars = [r'\\efit_aeqdsk:time',\n                 r'\\efit_aeqdsk:betan',\n                 r'\\efit_aeqdsk:betap',\n                 r'\\efit_aeqdsk:eout',\n                 r'\\efit_aeqdsk:li',\n                 r'\\efit_aeqdsk:otop',\n                 r'\\efit_aeqdsk:obott',\n                 r'\\efit_aeqdsk:q0',\n                 r'\\efit_aeqdsk:qstar',\n                 r'\\efit_aeqdsk:q95',\n                 r'\\efit_aeqdsk:vloopt',\n                 r'\\efit_aeqdsk:wplasm',\n                 r'\\efit_aeqdsk:ssep',\n                 r'\\efit_aeqdsk:xnnc']\n\n    # TODO: Populate metadata dict\n    def __init__(self, mdsplus_name, shot_id, data_columns=DEFAULT_SHOT_COLUMNS, data=None):\n        self._shot_id = shot_id\n        self._metadata = {\n            'labels': {},\n            'commit_hash': subprocess.check_output([\"git\", \"describe\", \"--always\"]).strip(),\n            'timestep': {},\n            'duration': {},\n            'description': \"\",\n            'disrupted': 100  # TODO: Fix\n        }\n        # Analysis tree has automatically generated Efit data. Efi18 is manually created Efit data\n        try:\n            self._analysis_tree = Tree('efit18', shot_id, mode=\"readonly\")\n            self._times = self._analysis_tree.getNode(\n                r\"\\efit18::efit_aeqdsk:time\").getData().data().astype('float64', copy=False)\n        except mdsExceptions.TreeFOPENR as e:\n            try:\n                self._analysis_tree = Tree(\n                    'analysis', shot_id, mode=\"readonly\")\n                self._times = self._analysis_tree.getNode(\n                    r\"\\analysis::efit_aeqdsk:time\").getData().data().astype('float64', copy=False)\n            except mdsExceptions.TreeFOPENR as f:\n                print(\"WARNING: No EFIT data found\")\n        self.data = data\n        if data is None:\n            self.data = pd.DataFrame()\n            self._populate_shot_data()\n\n    def _populate_shot_data(self):\n        self.data['times'] = self._times\n        # TODO: convert from bytes\n        self.data['commit_hash'] = self._metadata['commit_hash']\n        self.data['time_until_disrupt'] = self._calc_time_until_disrupt()\n        self.data['ip'], self.data['dip_dt'], self.data['dip_smoothed'], _, self.data[\n            'dipprog_dt'], self.data['ip_error'] = self._calc_Ip_parameters()\n        self.data['z_error'], _, self.data['zcur'], self.data['v_z'], self.data['z_times_v_z'] = self._calc_Z_parameters()\n        self.data['p_oh'], self.data['v_loop'] = self._calc_p_ohm_v_loop()\n        self.data['p_rad'], self.data['dprad_dt'], self.data['p_lh'], self.data[\n            'p_icrf'], self.data['p_input'], self.data['radiated_fraction'] = self._calc_power()\n        self.data['beta_n'], self.data['beta_p'], self.data['dbetap_dt'], self.data['kappa'], self.data['upper_gap'], self.data['lower_gap'], self.data['li'], self.data['dli_dt'], self.data[\n            'q0'], self.data['qstar'], self.data['q95'], _, self.data['Wmhd'], self.data['dWmhd_dt'], self.data['ssep'], self.data['n_over_ncrit'] = self._calc_EFIT_parameters()\n        self.data['kappa_area'] = self._calc_kappa_area()\n        self.data['v_0'] = self._calc_rotation_velocity()\n        # TODO: Populate when shot is missing from calibrated.txt\n        self.data['v_0_uncalibrated'] = [np.nan]*len(self.data)\n        # TODO: Ask about removing from database\n        self.data['v_mid'] = [np.nan]*len(self.data)\n        self.data['n_equal_1_mode'], self.data['n_equal_1_normalized'], _ = self._calc_n_equal_1_amplitude()\n        self.data['Te_width'] = self._calc_Ts_data()\n        self.data['ne_peaking'], self.data['Te_peaking'], self.data['pressure_peaking'] = self._calc_peaking_factor()\n        self.data['n_e'], self.data['dn_dt'], self.data['Greenwald_fraction'] = self._calc_densities()\n        self.data['I_efc'] = self._calc_efc_current()\n        self.data['SXR'] = self._calc_sxr_data()\n        # Check there are no floats(float32) since the SQL database only contains type doubles(float64)\n        float_columns = list(self.data.select_dtypes(\n            include=['float32']).columns)\n        print(float_columns)  # TODO: Change to an assert\n        # self.data[float_columns] = self.data[float_columns].astype('float64')\n\n    def get_active_wire_segments(self):\n        pcs_tree = Tree('pcs', self._shot_id)\n        segment_nodes = pcs_tree.getNodeWild(\"\\\\top.seg_*\")\n        # Collect active segments and their information\n        active_segments = []\n        for node in segment_nodes:\n            if node.isOn():\n                active_segments.append(\n                    [node, node.getNode(\":start_time\").getData().data()])\n        active_segments.sort(key=lambda n: n[1])\n        end_times = np.roll(np.asarray([n[1] for n in active_segments]), -1)\n        end_times[-1] = 12.383  # [s]\n        for i in range(len(active_segments)):\n            active_segments[i].append(end_times[i])\n        return active_segments\n\n    @staticmethod\n    def calc_time_until_disrupt():\n        pass\n\n    def _calc_time_until_disrupt(self):\n        if self._metadata['disrupted']:\n            if self._metadata['disrupted'] == -1:\n                raise ValueError(\"Shot disrupted but no t_disrupt found.\")\n            time_until_disrupt = self._metadata['disrupted'] - \\\n                self.data['times']\n        return time_until_disrupt\n\n    @staticmethod\n    def calc_IP_parameters(times, ip, magtime, ip_prog, pcstime):\n        dip = np.gradient(ip, magtime)\n        dip_smoothed = smooth(dip, 11)\n        dipprog_dt = np.gradient(ip_prog, pcstime)\n        ip_prog = interp1(pcstime, ip_prog, times,\n                          bounds_error=False, fill_value=ip_prog[-1])\n        dipprog_dt = interp1(pcstime, dipprog_dt, times, bounds_error=False)\n        ip = interp1(magtime, ip, times)\n        dip = interp1(magtime, dip, times)\n        dip_smoothed = interp1(magtime, dip_smoothed, times)\n        ip_error = ip-ip_prog\n        return ip, dip, dip_smoothed, ip_prog, dipprog_dt, ip_error\n\n    def _calc_Ip_parameters(self):\n        # Automatically generated\n        magnetics_tree = Tree('magnetics', self._shot_id)\n        active_segments = self.get_active_wire_segments()\n        # Default PCS timebase is 1 KHZ\n        pcstime = np.array(np.arange(-4, 12.383, .001))\n        ip_prog = np.full(pcstime.shape, np.nan)\n        # For each activate segment:\n        # 1.) Find the wire for IP control and check if it has non-zero PID gains\n        # 2.) IF it does, interpolate IP programming onto the PCS timebase\n        # 3.) Clip to the start and stop times of PCS timebase\n        for segment, start, end in active_segments:\n            # Ip wire can be one of 16 but is normally no. 16\n            for wire_index in range(16, 0, -1):\n                wire_node = segment.getNode(f\":P_{wire_index :02d}:name\")\n                if wire_node.getData().data() == 'IP':\n                    try:\n                        pid_gains = segment.getNode(\n                            f\":P_{wire_index :02d}:pid_gains\").getData().data()\n                        if np.any(pid_gains):\n                            sig_node = segment.getNode(f\":P_{wire_index :02d}\")\n                            signal_record = sig_node.getData()\n                            sigtime = signal_record.dim_of(0)\n                            signal = signal_record.data()\n                            ip_prog_temp = interp1(\n                                sigtime, signal, pcstime, bounds_error=False, fill_value=signal[-1])\n                            segment_indices = np.where(\n                                (pcstime &gt;= start) &amp; (pcstime &lt;= end))\n                            ip_prog[segment_indices] = ip_prog_temp[segment_indices]\n                    except mdsExceptions.MdsException as e:\n                        print(e)  # TODO: Change\n                else:\n                    continue\n                break\n        ip = magnetics_tree.getNode(r\"\\ip\").getData(\n        ).data().astype('float64', copy=False)\n        magtime = magnetics_tree.getNode(r\"\\ip\").getData().dim_of(0)\n        return CmodShot.calc_IP_parameters(self._times, ip, magtime, ip_prog, pcstime)\n\n    @staticmethod\n    def calc_Z_parameters(times, z_prog, pcstime, z_error_without_ip, ip, dpcstime):\n        z_error = z_error_without_ip/ip  # [m]\n        z_prog_dpcs = interp1(pcstime, z_prog, dpcstime)\n        z_cur = z_prog_dpcs + z_error  # [m]\n        v_z = np.gradient(z_cur, dpcstime)  # m/s\n        z_times_v_z = z_cur * v_z  # m^2/s\n        z_prog = interp1(pcstime, z_prog, times, 'linear', False, z_prog[-1])\n        z_error = -interp1(dpcstime, z_error, times,\n                           'linear', False, z_error[-1])\n        z_cur = -interp1(dpcstime, z_cur, times, 'linear', False, z_cur[-1])\n        v_z = interp1(dpcstime, v_z, times, 'linear', False, v_z[-1])\n        z_times_v_z = interp1(dpcstime, z_times_v_z, times,\n                              'linear', False, z_times_v_z[-1])\n        return z_error, z_prog, z_cur, v_z, z_times_v_z\n\n    def _calc_Z_parameters(self):\n        pcstime = np.array(np.arange(-4, 12.383, .001))\n        z_prog = np.empty(pcstime.shape)\n        z_prog.fill(np.nan)\n        z_prog_temp = z_prog.copy()\n        z_wire_index = -1\n        active_wire_segments = self.get_active_wire_segments()\n        for segment, start, end in active_wire_segments:\n            for wire_index in range(1, 17):\n                wire_node = segment.getNode(f\":P_{wire_index :02d}:name\")\n                if wire_node.getData().data() == \"ZCUR\":\n                    try:\n                        pid_gains = segment.getNode(\n                            f\":P_{wire_index :02d}:pid_gains\").getData().data()\n                        if np.any(pid_gains):\n                            sig_node = segment.getNode(f\":P_{wire_index :02d}\")\n                            signal_record = sig_node.getData()\n                            sigtime = signal_record.dim_of(0)\n                            signal = signal_record.data()\n                            z_prog_temp = interp1(\n                                sigtime, signal, pcstime, 'linear', False, fill_value=signal[-1])\n                            z_wire_index = wire_index\n                            segment_indices = [\n                                np.where((pcstime &gt;= start) &amp; (pcstime &lt;= end))]\n                            z_prog[segment_indices] = z_prog_temp[segment_indices]\n                            break\n                    except mdsExceptions.MdsException as e:\n                        print(e)\n                        continue  # TODO: Consider raising appropriate error\n                else:\n                    continue\n                break\n        if z_wire_index == -1:\n            # TODO: Make appropriate error\n            raise ValueError(\"No ZCUR wire was found\")\n        # Read in A_OUT, which is a 16xN matrix of the errors for *all* 16 wires for\n        # *all* of the segments. Note that DPCS time is usually taken at 10kHz.\n        hybrid_tree = Tree('hybrid', self._shot_id)\n        wire_errors_record = hybrid_tree.getNode(\n            r'\\top.hardware.dpcs.signals:a_out').getData()\n        wire_errors, dpcstime = wire_errors_record.data(\n        ), np.array(wire_errors_record.dim_of(1))  # s\n        # The value of Z_error we read is not in the units we want. It must be *divided* by a factor AND *divided* by the plasma current.\n        z_error_without_factor_and_ip = wire_errors[:, z_wire_index]\n        z_error_without_ip = np.empty(z_error_without_factor_and_ip.shape)\n        z_error_without_ip.fill(np.nan)\n        # Also, it turns out that different segments have different factors. So we\n        # search through the active segments (determined above), find the factors,\n        # and *divide* by the factor only for the times in the active segment (as\n        # determined from start_times and stop_times.\n        for i in range(len(active_wire_segments)):\n            segment, start, end = active_wire_segments[i]\n            z_factor = hybrid_tree.getNode(\n                fr'\\dpcs::top.seg_{i+1:02d}:p_{z_wire_index:02d}:predictor:factor').getData().data()\n            z_error_without_ip[np.where((dpcstime &gt;= start) &amp; (\n                dpcstime &lt;= end))] /= z_factor  # [A*m]\n        # Next we grab ip, which comes from a_in:input_056. This also requires\n        # *multiplication* by a factor.\n        # NOTE that I can't get the following ip_without_factor to work for shots\n        # before 2015.\n        # TODO: Try to fix this\n        if self._shot_id &gt; 1150101000:\n            ip_without_factor = hybrid_tree.getNode(\n                r'\\hybrid::top.hardware.dpcs.signals.a_in:input_056').getData().data()\n            ip_factor = hybrid_tree.getNode(\n                r'\\hybrid::top.dpcs_config.inputs:input_056:p_to_v_expr').getData().data()\n            ip = ip_without_factor*ip_factor  # [A]\n        else:\n            magnetics_tree = Tree('magnetics', self._shot_id)\n            ip_record = magnetics_tree.getNode(r'\\ip').getData()\n            ip = ip_record.data()\n            ip_time = ip_record.dim_of(0)\n            ip = interp1(ip_time, ip, dpcstime)\n        return CmodShot.calc_Z_parameters(self._times, z_prog, pcstime, z_error_without_ip, ip, dpcstime)\n\n    @staticmethod\n    def calc_p_oh_v_loop(times, v_loop, v_loop_time, li, efittime, dip_smoothed, ip):\n        # For simplicity, we use R0 = 0.68 m, but we could use \\efit_aeqdsk:rmagx\n        inductance = 4.0*np.pi*1.0e-7 * 0.68 * li/2.0\n        v_loop = interp1(v_loop_time, v_loop, times)\n        inductance = interp1(efittime, inductance, times)\n        v_inductive = inductance * dip_smoothed\n        v_resistive = v_loop - v_inductive\n        p_ohm = ip * v_resistive\n        return p_ohm, v_loop\n\n    def _calc_p_ohm_v_loop(self):\n        v_loop_record = self._analysis_tree.getNode(r\"\\top.mflux:v0\").getData()\n        v_loop = v_loop_record.data().astype('float64', copy=False)\n        v_loop_time = v_loop_record.dim_of(0)\n        if len(v_loop_time) &lt;= 1:\n            return None, None\n        li_record = self._analysis_tree.getNode(r\"\\efit_aeqdsk:li\").getData()\n        li = li_record.data().astype('float64', copy=False)\n        efittime = li_record.dim_of(0)\n        return CmodShot.calc_p_oh_v_loop(self._times, v_loop, v_loop_time, li, efittime, self.data['dip_smoothed'], self.data['ip'])\n\n    @staticmethod\n    def calc_power(times, p_lh, t_lh, p_icrf, t_icrf, p_rad, t_rad, p_ohm):\n        p_lh = interp1(t_lh, p_lh * 1.0e3, times,\n                       bounds_error=False) if p_lh is not None else np.zeros(len(times))\n        p_icrf = interp1(t_icrf, p_icrf * 1.0e6, times,\n                         bounds_error=False) if p_icrf is not None else np.zeros(len(times))\n        if len(t_rad) == 1 or p_rad is None:\n            p_rad = np.array([np.nan]*len(times))  # TODO: Fix\n            dprad = p_rad.copy()\n        else:\n            dprad = np.gradient(p_rad, t_rad)\n            p_rad = interp1(t_rad, p_rad, times)\n            dprad = interp1(t_rad, dprad, times)\n        p_input = p_ohm + p_lh + p_icrf\n        rad_fraction = p_rad/p_input\n        rad_fraction[rad_fraction == np.inf] = np.nan\n        return p_rad, dprad, p_lh, p_icrf, p_input, rad_fraction\n\n    def _calc_power(self):\n\"\"\"\n        NOTE: the timebase for the LH power signal does not extend over the full\n            time span of the discharge.  Therefore, when interpolating the LH power\n            signal onto the \"timebase\" array, the LH signal has to be extrapolated\n            with zero values.  This is an option in the 'interp1' routine.  If the\n            extrapolation is not done, then the 'interp1' routine will assign NaN\n            (Not-a-Number) values for times outside the LH timebase, and the NaN's\n            will propagate into p_input and rad_fraction, which is not desirable.\n        \"\"\"\n        values = [None]*6\n        trees = ['LH', 'RF', 'spectroscopy']\n        nodes = [r'\\LH::TOP.RESULTS:NETPOW',\n                 r\"\\rf::rf_power_net\", r\"\\twopi_diode\"]\n        for i in range(3):\n            try:\n                tree = Tree(trees[i], self._shot_id)\n                record = tree.getNode(nodes[i])\n                values[2*i] = record.data().astype('float64', copy=False)\n                values[2*i + 1] = record.dim_of(0)\n            except mdsExceptions.TreeFOPENR as e:\n                continue\n        return CmodShot.calc_power(self._times, *values, self.data['p_oh'])\n\n    # TODO: Replace with for loop like in D3D shot class\n    def _calc_EFIT_parameters(self):\n        efittime = self._analysis_tree.getNode(r'\\efit_aeqdsk:time')\n        beta_N = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:betan').getData().data().astype('float64', copy=False)\n        beta_p = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:betap').getData().data().astype('float64', copy=False)\n        kappa = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:eout').getData().data().astype('float64', copy=False)\n        li = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:li').getData().data().astype('float64', copy=False)\n        upper_gap = self._analysis_tree.getNode(r'\\efit_aeqdsk:otop').getData(\n        ).data().astype('float64', copy=False)/100.0  # meters\n        lower_gap = self._analysis_tree.getNode(r'\\efit_aeqdsk:obott').getData(\n        ).data().astype('float64', copy=False)/100.0  # meters\n        q0 = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:q0').getData().data().astype('float64', copy=False)\n        qstar = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:qstar').getData().data().astype('float64', copy=False)\n        q95 = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:q95').getData().data().astype('float64', copy=False)\n        V_loop_efit = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:vloopt').getData().data().astype('float64', copy=False)\n        Wmhd = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:wplasm').getData().data().astype('float64', copy=False)\n        ssep = self._analysis_tree.getNode(r'\\efit_aeqdsk:ssep').getData(\n        ).data().astype('float64', copy=False)/100.0  # meters\n        n_over_ncrit = -self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:xnnc').getData().data().astype('float64', copy=False)\n        beta_p_dot = np.gradient(beta_p, efittime)\n        li_dot = np.gradient(li, efittime)\n        dWmhd_dt = np.gradient(Wmhd, efittime)\n        beta_N = interp1(efittime, beta_N, self._times)\n        beta_p = interp1(efittime, beta_p, self._times)\n        kappa = interp1(efittime, kappa, self._times)\n        li = interp1(efittime, li, self._times)\n        upper_gap = interp1(efittime, upper_gap, self._times)\n        lower_gap = interp1(efittime, lower_gap, self._times)\n        q0 = interp1(efittime, q0, self._times)\n        qstar = interp1(efittime, qstar, self._times)\n        q95 = interp1(efittime, q95, self._times)\n        V_loop_efit = interp1(efittime, V_loop_efit, self._times)\n        Wmhd = interp1(efittime, Wmhd, self._times)\n        beta_p_dot = interp1(efittime, beta_p_dot, self._times)\n        li_dot = interp1(efittime, li_dot, self._times)\n        dWmhd_dt = interp1(efittime, dWmhd_dt, self._times)\n        ssep = interp1(efittime, ssep, self._times)\n        n_over_ncrit = interp1(efittime, n_over_ncrit, self._times)\n        return beta_N, beta_p, beta_p_dot, kappa, upper_gap, lower_gap, li, li_dot, q0, qstar, q95, V_loop_efit, Wmhd, dWmhd_dt, ssep, n_over_ncrit\n\n    @staticmethod\n    def calc_kappa_area(times, aminor, area, a_times):\n        return interp1(a_times, area/(np.pi * aminor**2), times)\n\n    def _calc_kappa_area(self):\n        aminor = self._analysis_tree.getNode(\n            r'\\efit_a_eqdsk:aminor').getData().data().astype('float64', copy=False)\n        area = self._analysis_tree.getNode(\n            r'\\efit_a_eqdsk:area').getData().data().astype('float64', copy=False)\n        times = self._analysis_tree.getNode(\n            r'\\efit_aeqdsk:time').getData().data().astype('float64', copy=False)\n        return CmodShot.calc_kappa_area(self._times, aminor, area, times)\n\n    @staticmethod\n    def calc_rotation_velocity(times, intensity, time, vel, hirextime):\n\"\"\"\n        Uses spectroscopy graphs of ionized(to hydrogen and helium levels) Argon to calculate velocity. Because of the heat profile of the plasma, suitable measurements are only found near the center\n        \"\"\"\n        v_0 = np.empty(len(time))\n        # Check that the argon intensity pulse has a minimum count and duration threshold\n        valid_indices = np.where(intensity &gt; 1000 &amp; intensity &lt; 10000)\n        # Matlab code just multiplies by time delta but that doesn't work in the case where we have different time deltas\n        # Instead we sum the time deltas for all valid indices to check the total duration\n        if np.sum(time[valid_indices+1] - time[valid_indices]) &gt;= .2:\n            v_0 = interp1(hirextime, vel, time)\n            # TODO: Determine better threshold\n            v_0[np.where(abs(v_0) &gt; 200)] = np.nan\n            v_0 *= 1000.0\n        v_0 = interp1(time, v_0, times)\n        return v_0\n\n    # TODO: Calculate v_mid\n    def _calc_rotation_velocity(self):\n        with importlib_resources.path(\n                disruption_py.data, 'lock_mode_calib_shots.txt') as calib_path:\n            calibrated = pd.read_csv(calib_path)\n        # Check to see if shot was done on a day where there was a locked\n        # mode HIREX calibration by cross checking with list of calibrated\n        # runs. If not calibrated, return NaN outputs.\n        if self._shot_id not in calibrated:\n            v_0 = np.empty(len(self._times))\n            v_0.fill(np.nan)\n            return v_0\n        try:\n            spec_tree = Tree('spectroscopy', self._shot_id)\n            intensity_record = spec_tree.getNode(\n                '.hirex_sr.analysis.a:int').getData()\n            intensity = intensity_record.data().astype('float64', copy=False)\n            time = intensity_record.dim_of(0)\n            vel_record = spec_tree.getNode(\n                '.hirex_sr.analysis.a:vel').getData()\n            vel = vel_record.data().astype('float64', copy=False)\n            hirextime = vel_record.dim_of(0)\n        except mdsExceptions.TreeFOPENR as e:\n            print(\n                \"WARNING: failed to open necessary tress for rotational velocity calculations.\")\n            v_0 = np.empty(len(self._times))\n            v_0.fill(np.nan)\n            return v_0\n        return CmodShot.calc_rotation_velocity(self._times, intensity, time, vel, hirextime)\n\n    # TODO: Split into static and instance method\n    @staticmethod\n    def calc_n_equal_1_amplitude():\n        pass\n\n    def _calc_n_equal_1_amplitude(self):\n\"\"\" Calculate n=1 amplitude and phase for the disruption warning database\n        using the four BP13 Bp sensors near the midplane on the outboard vessel\n        wall.  The calculation is done by using a least squares fit to an\n        expansion in terms of n = 0 &amp; 1 toroidal harmonics.  The BP13 sensors are\n        part of the set used for plasma control and equilibrium reconstruction,\n        and their signals have been analog integrated (units: tesla), so they\n        don't have to be numerically integrated.  These four sensors were working\n        well in 2014, 2015, and 2016.  I looked at our locked mode MGI run on\n        1150605, and the different applied A-coil phasings do indeed show up on\n        the n=1 signal.\n\n        N=1 toroidal assymmetry in the magnetic fields\n        \"\"\"\n        n_equal_1_amplitude = np.empty(len(self._times))\n        n_equal_1_amplitude.fill(np.nan)\n        n_equal_1_normalized = n_equal_1_amplitude.copy()\n        n_equal_1_phase = n_equal_1_amplitude.copy()\n        # These sensors are placed toroidally around the machine. Letters refer to the 2 ports the sensors were placed between.\n        bp13_names = ['BP13_BC', 'BP13_DE', 'BP13_GH', 'BP13_JK']\n        bp13_signals = np.empty((len(self._times), len(bp13_names)))\n        mag_tree = Tree('magnetics', self._shot_id)\n        path = r\"\\mag_bp_coils.\"\n        bp_node_names = mag_tree.getNode(path + \"nodename\").getData().data()\n        phi = mag_tree.getNode(path + 'phi').getData().data()\n        btor_pickup_coeffs = mag_tree.getNode(\n            path + \"btor_pickup\").getData().data()\n        _, bp13_indices, _ = np.intersect1d(\n            bp_node_names, bp13_names, return_indices=True)\n        bp13_phi = phi[bp13_indices] + 360  # INFO\n        bp13_btor_pickup_coeffs = btor_pickup_coeffs[bp13_indices]\n        btor_record = mag_tree.getNode(r\"\\btor\").getData()\n        btor = btor_record.data()\n        t_mag = btor_record.dim_of(0)\n        # Toroidal power supply takes time to turn on, from ~ -1.8 and should be on by t=-1. So pick the time before that to calculate baseline\n        baseline_indices = np.where(t_mag &lt;= -1.8)\n        btor = btor - np.mean(btor[baseline_indices])\n        path = r\"\\mag_bp_coils.signals.\"\n        # For each sensor:\n        # 1. Subtract baseline offset\n        # 2. Subtract btor pickup\n        # 3. Interpolate bp onto shot timebase\n        for i in range(len(bp13_names)):\n            signal = mag_tree.getNode(path + bp13_names[i]).getData().data()\n            if len(signal) == 1:\n                print(\"WARNING: Can't fit with signal. Returning nans\")\n                return n_equal_1_amplitude, n_equal_1_normalized, n_equal_1_phase\n            baseline = np.mean(signal[baseline_indices])\n            signal = signal - baseline\n            signal = signal - bp13_btor_pickup_coeffs[i]*btor\n            bp13_signals[:, i] = interp1(t_mag, signal, self._times)\n        # TODO: Examine edge case behavior of sign\n        polarity = np.sign(np.mean(btor))\n        btor_magnitude = btor*polarity\n        btor_magnitude = interp1(t_mag, btor_magnitude, self._times)\n        # Create the 'design' matrix ('A') for the linear system of equations:\n        # Bp(phi) = A1 + A2*sin(phi) + A3*cos(phi)\n        ncoeffs = 3\n        A = np.empty((len(bp13_names), ncoeffs))\n        A[:, 0] = np.ones(4)\n        A[:, 1] = np.sin(bp13_phi*np.pi/180.0)\n        A[:, 2] = np.cos(bp13_phi*np.pi/180.0)\n        coeffs = np.linalg.pinv(A) @ bp13_signals.T\n        # The n=1 amplitude at each time is sqrt(A2^2 + A3^2)\n        # The n=1 phase at each time is arctan(-A2/A3), using complex number\n        # phasor formalism, exp(i(phi - delta))\n        n_equal_1_amplitude = np.sqrt(coeffs[1, :]**2 + coeffs[2, :]**2)\n        # TODO: Confirm arctan2 = atan2\n        n_equal_1_phase = np.arctan2(-coeffs[1, :], coeffs[2, :])\n        n_equal_1_normalized = n_equal_1_amplitude / btor_magnitude\n\n        # INFO: Debugging purpose block of code at end of matlab file\n        # INFO: n_equal_1_amplitude vs n_equal_1_mode\n        return n_equal_1_amplitude, n_equal_1_normalized, n_equal_1_phase\n\n    @staticmethod\n    def calc_densities(times, n_e, t_n, ip, t_ip, a_minor, t_a):\n        if len(n_e) == len(t_n):\n            nan_arr = np.empty(len(times))\n            nan_arr.fill(np.nan)\n            return nan_arr, nan_arr.copy(), nan_arr.copy()\n        dn_dt = np.gradient(n_e, t_n)\n        n_e = interp1(t_n, n_e, times)\n        dn_dt = interp1(t_n, dn_dt, times)\n        ip = -ip/1e6  # Convert from A to MA and take positive value\n        ip = interp1(t_ip, ip, times)\n        a_minor = interp1(t_a, a_minor, times)\n        n_G = ip/(np.pi*a_minor**2)*1e20  # Greenwald density in m ^-3\n        g_f = abs(n_e/n_G)\n        return n_e, dn_dt, g_f\n\n    def _calc_densities(self):\n        try:\n            e_tree = Tree('electrons', self._shot_id)\n            n_e_record = e_tree.getNode(r'.tci.results:nl_04/0.6').getData()\n            n_e = n_e_record.data().astype('float64', copy=False)\n            t_n = n_e_record.dim_of(0)\n            mag_tree = Tree('magnetics', self._shot_id)\n            ip_record = mag_tree.getNode(r'\\ip').getData()\n            ip = ip_record.data().astype('float64', copy=False)\n            t_ip = ip_record.dim_of(0)\n            a_tree = Tree('analysis', self._shot_id)\n            a_minor_record = a_tree.getNode(\n                r'.efit.results.a_eqdsk:aminor').getData()\n            t_a = a_minor_record.dim_of(0)\n            a_minor = a_minor_record.data().astype('float64', copy=False)\n        except Exception as e:\n            return None, None, None\n        return CmodShot.calc_densities(self._times, n_e, t_n, ip, t_ip, a_minor, t_a)\n\n    @staticmethod\n    def calc_efc_current(times, iefc, t_iefc):\n        return interp1(t_iefc, iefc, times, 'linear')\n\n    def _calc_efc_current(self):\n        try:\n            eng_tree = Tree('engineering', self._shot_id)\n            iefc_record = eng_tree.getNode(r\"\\efc:u_bus_r_cur\").getData()\n            iefc, t_iefc = iefc_record.data(), iefc_record.dim_of(0)\n        except Exception as e:\n            print(e)\n            return None\n        return CmodShot.calc_efc_current(self._times, iefc, t_iefc)\n\n    # TODO: Split\n    @staticmethod\n    def calc_Ts_data(times, ts_data, ts_time, ts_z):\n        te_hwm = np.full(len(ts_time), np.nan)\n        valid_times = np.where(ts_time &gt; 0)\n        # TODO: Vectorize\n        for i in range(len(valid_times)):\n            y = ts_data[:, valid_times[i]]\n            ok_indices = np.where(y != 0)\n            if len(ok_indices) &gt; 2:\n                y = y[ok_indices]\n                z = ts_z[ok_indices]\n                _, _, sigma = gaussian_fit(z, y)\n                te_hwm[valid_times[i]] = sigma*1.1774  # 50%\n        te_hwm = interp1(ts_time, te_hwm, times)\n        return te_hwm\n\n    def _calc_Ts_data(self):\n        # TODO: Guassian vs parabolic fit for te profile\n        te_hwm = np.empty((len(self._times)))\n        electron_tree = Tree(\"electrons\", self._shot_id)\n\n        # Read in Thomson core temperature data, which is a 2-D array, with the\n        # dependent dimensions being time and z (vertical coordinate)\n        node_path = \".yag_new.results.profiles\"\n        try:\n            ts_data = electron_tree.getNode(\n                node_path + \":te_rz\").getData().data()\n            ts_time = electron_tree.getNode(\n                node_path + \":te_rz\").getData().dim_of(0)\n            ts_z = electron_tree.getNode(\n                node_path + \":z_sorted\").getData().data()\n        except mdsExceptions.MdsException as e:\n            print(e)  # TODO: Change\n            te_hwm.fill(np.nan)\n            return te_hwm\n        return CmodShot.calc_Ts_data(self._times, ts_data, ts_time, ts_z)\n\n    # TODO: Finish\n    @staticmethod\n    def calc_peaking_factor():\n        pass\n\n    def _calc_peaking_factor(self):\n        ne_PF = np.full(len(self._times), np.nan)\n        Te_PF = ne_PF.copy()\n        pressure_PF = ne_PF.copy()\n        if (self._shot_id &gt; 1120000000 and self._shot_id &lt; 1120213000) or (self._shot_id &gt; 1140000000 and self._shot_id &lt; 1140227000) or (self._shot_id &gt; 1150000000 and self._shot_id &lt; 1150610000) or (self._shot_id &gt; 1160000000 and self._shot_id &lt; 1160303000):\n            return ne_PF, Te_PF, pressure_PF\n        try:\n            efit_tree = Tree('cmod', self._shot_id)\n            z0 = 0.01*efit_tree.getNode(r'\\efit_aeqdsk:zmagx').getData().data()\n            aminor = efit_tree.getNode(r'\\efit_aeqdsk:aminor').getData().data()\n            kappa = efit_tree.getNode(r'\\efit_aeqdsk:kappa').getData().data()\n            efit_time = efit_tree.getNode(\n                r'\\efit_aeqdsk:aminor').getData().dim_of(0)\n            bminor = aminor*kappa\n            electron_tree = Tree('electroncs', self._shot_id)\n            node_ext = '.yag_new.results.profiles'\n            nl_ts1, nl_ts2, nl_tci1, nl_tci2, _, _ = self.compare_ts_tci(\n                electron_tree, nlnum=4)\n            TS_te = electron_tree.getNode(\n                f\"{node_ext}:te_rz\").getData().data()*1000*11600\n            tets_edge = electron_tree.getNode(r'\\ts_te').getData().data()*11600\n            TS_te = np.concatenate((TS_te, tets_edge))\n            TS_time = electron_tree.getNode(\n                f\"{node_ext}:te_rz\").getData().dim_of(0)\n            TS_z = electron_tree.getNode(\n                f\"{node_ext}:z_sorted\").getData().data()\n            zts_edge = electron_tree.getNode(f\"\\fiber_z\").getData().data()\n            TS_z = np.concatenate((TS_z, zts_edge))\n            if len(zts_edge) != tets_edge.shape[1]:\n                return ne_PF, Te_PF, pressure_PF\n            Te_PF = Te_PF[:len(TS_time)]\n            itimes = np.where(TS_time &gt; 0 &amp; TS_time &lt; self._times[-1])\n            bminor = interp1(efit_time, bminor, TS_time)\n            z0 = interp1(efit_time, z0, TS_time)\n            for i in range(len(itimes)):\n                Te_arr = TS_te[itimes[i], :]\n                indx = np.where(Te_arr &gt; 0)\n                if len(indx) &lt; 10:\n                    continue\n                Te_arr = Te_arr[indx]\n                TS_z_arr = TS_z[indx]\n                sorted_indx = np.argsort(TS_z_arr)\n                Ts_z_arr = Ts_z_arr[sorted_indx]\n                Te_arr = Te_arr[sorted_indx]\n                z_arr = np.linspace(z0[itimes[i]], TS_z_arr[-1], len(Ts_z_arr))\n                Te_arr = interp1(TS_z_arr, Te_arr, z_arr)\n                core_index = np.where(z_arr &lt; (\n                    z0[itimes[i]] + .2*bminor[itimes[i]]) &amp; z_arr &gt; (z0[itimes[i]] - .2*bminor[itimes[i]]))\n                if len(core_index) &lt; 2:\n                    continue\n                Te_PF[itimes[i]] = np.mean(Te_arr[core_index])/np.mean(Te_arr)\n            Te_PF = interp1(TS_time, Te_PF, self._times)\n            calib = np.nan\n            return ne_PF, Te_PF, pressure_PF\n\n        except mdsExceptions.MdsException as e:\n            return ne_PF, Te_PF, pressure_PF\n\n    # The following methods are translated from IDL code.\n    def compare_ts_tci(self, electron_tree, nlnum=4):\n\"\"\"\n        Comparison between chord integrated Thomson electron density and TCI results.\n        \"\"\"\n        core_mult = 1.0\n        edge_mult = 1.0\n        nl_ts1 = [1e32]\n        nl_ts2 = [1e32]\n        nl_tci1 = [1e32]\n        nl_tci2 = [1e32]\n        ts_time1 = [1e32]\n        ts_time2 = [1e32]\n        tci_time = electron_tree.getNode(\n            \".YAG_NEW.RESULTS.PROFILES:NE_RZ\").getData().dim_of(0)\n        tci_record = electron_tree.getNode(\".TCI.RESULTS:NL_{nlnum:02d}\")\n        tci = tci_record.data()\n        tci_t = tci_record.dim_of(0)\n        nlts, nlts_t = self.integrate_ts_tci(nlnum)\n        t0 = np.amin(nlts_t)\n        t1 = np.amax(nlts_t)\n        nyag1, nyag2, indices1, indices2 = self.parse_yags()\n        if nyag1 &gt; 0:\n            indices1 += 1\n            ts_time1 = tci_time[indices1]\n            valid_indices = np.where(ts_time1 &gt;= t0 &amp; ts_time1 &lt;= t1)\n            if valid_indices.size &gt; 0:\n                nl_tci1 = interp1(tci_t, tci, ts_time1[valid_indices])\n                nl_ts1 = interp1(nlts_t, nlts, ts_time1[valid_indices])\n                time1 = ts_time1[valid_indices]\n        else:\n            time1 = -1\n        if nyag2 &gt; 0:\n            indices2 += 1\n            ts_time2 = tci_time[indices2]\n            valid_indices = np.where(ts_time2 &gt;= t0 &amp; ts_time2 &lt;= t1)\n            if valid_indices.size &gt; 0:\n                nl_tci1 = interp1(tci_t, tci, ts_time2[valid_indices])\n                nl_ts1 = interp1(nlts_t, nlts, ts_time2[valid_indices])\n                time2 = ts_time2[valid_indices]\n        else:\n            time2 = -1\n        return nl_ts1, nl_ts2, nl_tci1, nl_tci2, time1, time2\n\n    def parse_yags(self):\n        electron_tree = Tree('electrons', self._shot_id)\n        nyag1 = electron_tree.getNode(r'\\knobs:pulses_q').getData().data()\n        nyag2 = electron_tree.getNode(r'\\knobs:pulses_q_2').getData().data()\n        indices1 = -1\n        indices2 = -1\n        dark = electron_tree.getNode(r'\\n_dark_prior').getData().data()\n        ntotal = electron_tree.getNode(r'\\n_total').getData().data()\n        nt = ntotal-dark\n        if nyag1 == 0:\n            if nyag2 != 0:\n                indices2 = np.arange(nyag2)\n        else:\n            if nyag2 == 0:\n                indices1 = np.arange(nyag1)\n            else:\n                if nyag1 == nyag2:\n                    indices1 = 2*np.arange(nyag1)\n                    indices2 = indices1 + 1\n                else:\n                    if nyag1 == nyag2:\n                        indices1 = 2*np.arange(nyag1)\n                        indices2 = indices1+1\n                    else:\n                        indices1 = 2*np.arange(nyag1) + (nyag1 &gt; nyag2)\n                        indices2 = np.concatenate(\n                            (2*np.arange(nyag2) + (nyag1 &lt; nyag2), 2*nyag2 + np.arange(nyag1-nyag2-1)))\n        v_ind1 = np.where(indices1 &lt; nt)\n        if nyag1 &gt; 0 and v_ind1.size &gt; 0:\n            indices1 = indices1[v_ind1]\n        else:\n            indices1 = -1\n        v_ind2 = np.where(indices2 &lt; nt)\n        if nyag2 &gt; 0 and v_ind2.size &gt; 0:\n            indices2 = indices2[v_ind2]\n        else:\n            indices2 = -1\n        return nyag1, nyag2, indices1, indices2\n\n    def integrate_ts_tci(self, nlnum):\n\"\"\"\n        Integrate Thomson electron density measurement to the line integrated electron density for comparison with two color interferometer (TCI) measurement results\n        \"\"\"\n        core_mult = 1.0\n        edge_mult = 1.0\n        nlts = 1e32\n        nlts_t = 1e32\n        t, z, n_e, n_e_sig = self.map_ts2tci(nlnum)\n        if z[0, 0] == 1e32:\n            return None, None  # TODO: Log and maybe return nan arrs\n        nts = len(t)\n        nlts_t = t\n        nlts = np.full(t.shape, np.nan)\n        for i in range(len(nts)):\n            ind = np.where(np.abs(z[i, :]) &lt; 0.5 &amp; n_e[i, :] &gt;\n                           0 &amp; n_e[i, :] &lt; 1e21 &amp; n_e[i, :]/n_e_sig[i, :] &gt; 2)\n            if len(ind) &lt; 3:\n                nlts[i] = 0\n            else:\n                x = z[i, ind]\n                y = n_e[i, ind]\n                values_uniq, ind_uniq = np.unique(x, return_index=True)\n                y = y[ind_uniq]\n                nlts[i] = np.trapz(y, x)\n        return nlts, nlts_t\n\n    def map_ts2tci(self, nlnum):\n        core_mult = 1.0\n        edge_mult = 1.0\n        t = [1e32]\n        z = [1e32]\n        n_e = [1e32]\n        n_e_sig = [1e32]\n        flag = 1\n        valid_indices, efit_times = self.efit_check()\n        cmod_tree = Tree('cmod', self._shot_id)\n        ip = cmod_tree.getNode(r'\\ip').getData().data()\n        if np.mean(ip) &gt; 0:\n            flag = 0\n        t1 = np.amin(efit_times)\n        t2 = np.amax(efit_times)\n        analysis_tree = Tree('analysis', self._shot_id)\n        psia = analysis_tree.getNode(r'\\efit_aeqdsk:SIBDRY').getData().data()\n        psia_t = analysis_tree.getNode(\n            r'\\efit_aeqdsk:SIBDRY').getData().dim_of(0)\n        psi_0 = analysis_tree.getNode(r'\\efit_aeqdsk:SIMAGX')\n        electron_tree = Tree('electrons', self._shot_id)\n        nets_core = electron_tree.getNode(\n            '.YAG_NEW.RESULTS.PROFILES:NE_RZ').getData().data()\n        nets_core_t = electron_tree.getNode(\n            '.YAG_NEW.RESULTS.PROFILES:NE_RZ').getData().dim_of(0)\n        nets_core_err = electron_tree.getNode(\n            '.YAG_NEW.RESULTS.PROFILES:NE_ERR').getData().data()\n        zts_core = electron_tree.getNode(\n            '.YAG_NEW.RESULTS.PROFILES:Z_SORTED').getData().data()\n        mts_core = len(zts_core)\n        zts_edge = electron_tree.getNode(r'\\fiber_z').getData().data()\n        mts_edge = len(zts_edge)\n        try:\n            nets_edge = electron_tree.getNode(r'\\ts_ne').getData().data()\n            nets_edge_err = electron_tree.getNode(\n                r'\\ts_ne_err').getData().data()\n        except mdsExceptions.mdsException as err:\n            nets_edge = np.zeros((len(nets_core[:, 1]), mts_edge))\n            nets_edge_err = nets_edge + 1e20\n        mts = mts_core + mts_edge\n        rts = electron_tree.getNode(\n            '.YAG.RESULTS.PARAM:R') + np.zeros((1, mts))\n        rtci = electron_tree.getNode('.tci.results:rad').getData().data()\n        nts = len(nets_core_t)\n        zts = np.zeros((1, mts))\n        zts[:mts_core+1] = zts_core\n        zts[mts_core:] = zts_edge\n        nets = np.zeros((nts, mts))\n        nets_err = np.zeros((nts, mts))\n        nets[:, :mts_core+1] = nets_core*core_mult\n        nets_err[:, :mts_core+1] = nets_core_err*core_mult\n        nets[:, mts_core+1:] = nets_edge*edge_mult\n        nets_err[:, mts_core+1:] = nets_edge_err*edge_mult\n        valid_indices = np.where(nets_core_t &gt;= t1 &amp; nets_core_t &lt;= t2)\n        if valid_indices.size == 0:\n            return t, z, n_e, n_e_sig\n        nets_core_t = nets_core_t[valid_indices]\n        nets = nets[valid_indices]\n        nets_err = nets_err[valid_indices]\n        psits = self.efit_rz2psi(rts, zts, nets_core_t)\n        mtci = 101\n        ztci = -0.4 + .8*np.arange(0, mtci)/(mtci-1)\n        rtci = rtci[nlnum] + np.zeros((1, mtci))\n        psitci = self.efit_rz2psi(rtci, ztci, nets_core_t)\n        psia = interp1(psia_t, psia, nets_core_t)\n        psi_0 = interp1(psia_t, psi_0, nets_core_t)\n        nts = len(nets_core_t)\n        for i in range(len(nts)):\n            psits[i, :] = (psits[i, :]-psi_0[i])/(psia[i]-psi_0[i])\n            psitci[i, :] = (psitci[i, :]-psi_0[i])/(psia[i]-psi_0[i])\n        zmapped = np.zeros((nts, 2*mts)) + 1e32\n        nemapped = zmapped.copy()\n        nemapped_err = zmapped.copy()\n        for i in range(len(nts)):\n            index = np.argmin(\n                psitci[i, :]) if flag else np.argmax(psitci[i, :])\n            psi_val = psitci[i, index]\n            for j in range(len(mts)):\n                if (flag and psits[i, j] &gt;= psi_val) or (not flag and psits[i, j] &lt;= psi_val):\n                    a1 = interp1(psitci[i, :index],\n                                 ztci[:index], psits[i, j])\n                    a2 = interp1(psitci[i, index:], ztci[index:], psits[i, j])\n                    zmapped[i, np.arange(j, j+mts+1)] = np.arange(a1, a2)\n                    nemapped[i, np.arange(j, j+mts+1)] = nets[i, j]\n                    nemapped_err[i, np.arange(j, j+mts+1)] = nets_err[i, j]\n            sorted_indices = np.argsort(zmapped[i, :])\n            zmapped[i, :] = zmapped[i, sorted_indices]\n            nemapped[i, :] = nemapped[i, sorted_indices]\n            nemapped_err[i, :] = nemapped_err[i, sorted_indices]\n        z = zmapped\n        n_e = nemapped\n        n_e_sig = nemapped_err\n        t = nets_core_t\n        return t, z, n_e, n_e_sig\n\n    # TODO: Move to utils\n    def efit_rz2psi(self, r, z, t, tree='analysis'):\n        psi = np.full((len(r), len(t)), np.nan)\n        z = z.astype('float32')  # TODO: Ask if this change is necessary\n        psi_tree = Tree(tree, self._shot_id)\n        psi_record = psi_tree.getNode(r'\\efit_geqdsk:psirz').getData()\n        psirz = psi_record.data()\n        rgrid = psi_record.dim_of(0)\n        zgrid = psi_record.dim_of(1)\n        times = psi_record.dim_of(2)\n        rgrid, zgrid = np.meshgrid(rgrid, zgrid, indexing='ij')\n        for i in range(len(t)):\n            # Select EFIT times closest to the requested times\n            indx = np.min(np.abs(times - t[i]))\n            psi[:, i] = interp2(rgrid, zgrid, psirz[:, :, indx], r, z, 'cubic')\n        return psi\n\n    def efit_check(self):\n\"\"\"\n        # TODO: Get description from Jinxiang\n        \"\"\"\n        analysis_tree = Tree('analysis', self._shot_id)\n        values = analysis_tree.getNode(\n            '_lf=\\analysis::efit_aeqdsk:lflag,_l0=((sum(_lf,1) - _lf[*,20] - _lf[*,1])==0),_n=\\analysis::efit_fitout:nitera,(_l0 and (_n&gt;4))').getData().data()\n        valid_indices = np.nonzero(values)\n        times = analysis_tree.getNode('_lf').getData().dim_of(0)\n        return valid_indices, times[valid_indices]\n\n    @staticmethod\n    def calc_sxr_data():\n        pass\n    # TODO: get more accurate description of soft x-ray data\n\n    def _calc_sxr_data(self):\n\"\"\" \"\"\"\n        sxr = np.empty(len(self._times))\n        try:\n            tree = Tree('xtomo', self._shot_id)\n            sxr_record = tree.getNode(\n                r'\\top.brightnesses.array_1:chord_16').getData()\n            sxr = sxr_record.data().astype('float64', copy=False)\n            t_sxr = sxr_record.dim_of(0)\n            sxr = interp1(t_sxr, sxr, self._times)\n        except mdsExceptions.TreeFOPENR as e:\n            print(\"WARNING: Failed to get SXR data\")\n        return sxr\n\n    def __getitem__(self, key):\n        return self._metadata if key == 'metadata' else self.data[key]\n</code></pre>"},{"location":"shots-reference/#disruption_py.shots.cmod_shot.CModShot.calc_rotation_velocity","title":"<code>calc_rotation_velocity(times, intensity, time, vel, hirextime)</code>  <code>staticmethod</code>","text":"<p>Uses spectroscopy graphs of ionized(to hydrogen and helium levels) Argon to calculate velocity. Because of the heat profile of the plasma, suitable measurements are only found near the center</p> Source code in <code>disruption_py\\shots\\cmod_shot.py</code> <pre><code>@staticmethod\ndef calc_rotation_velocity(times, intensity, time, vel, hirextime):\n\"\"\"\n    Uses spectroscopy graphs of ionized(to hydrogen and helium levels) Argon to calculate velocity. Because of the heat profile of the plasma, suitable measurements are only found near the center\n    \"\"\"\n    v_0 = np.empty(len(time))\n    # Check that the argon intensity pulse has a minimum count and duration threshold\n    valid_indices = np.where(intensity &gt; 1000 &amp; intensity &lt; 10000)\n    # Matlab code just multiplies by time delta but that doesn't work in the case where we have different time deltas\n    # Instead we sum the time deltas for all valid indices to check the total duration\n    if np.sum(time[valid_indices+1] - time[valid_indices]) &gt;= .2:\n        v_0 = interp1(hirextime, vel, time)\n        # TODO: Determine better threshold\n        v_0[np.where(abs(v_0) &gt; 200)] = np.nan\n        v_0 *= 1000.0\n    v_0 = interp1(time, v_0, times)\n    return v_0\n</code></pre>"},{"location":"shots-reference/#disruption_py.shots.cmod_shot.CModShot.compare_ts_tci","title":"<code>compare_ts_tci(electron_tree, nlnum=4)</code>","text":"<p>Comparison between chord integrated Thomson electron density and TCI results.</p> Source code in <code>disruption_py\\shots\\cmod_shot.py</code> <pre><code>def compare_ts_tci(self, electron_tree, nlnum=4):\n\"\"\"\n    Comparison between chord integrated Thomson electron density and TCI results.\n    \"\"\"\n    core_mult = 1.0\n    edge_mult = 1.0\n    nl_ts1 = [1e32]\n    nl_ts2 = [1e32]\n    nl_tci1 = [1e32]\n    nl_tci2 = [1e32]\n    ts_time1 = [1e32]\n    ts_time2 = [1e32]\n    tci_time = electron_tree.getNode(\n        \".YAG_NEW.RESULTS.PROFILES:NE_RZ\").getData().dim_of(0)\n    tci_record = electron_tree.getNode(\".TCI.RESULTS:NL_{nlnum:02d}\")\n    tci = tci_record.data()\n    tci_t = tci_record.dim_of(0)\n    nlts, nlts_t = self.integrate_ts_tci(nlnum)\n    t0 = np.amin(nlts_t)\n    t1 = np.amax(nlts_t)\n    nyag1, nyag2, indices1, indices2 = self.parse_yags()\n    if nyag1 &gt; 0:\n        indices1 += 1\n        ts_time1 = tci_time[indices1]\n        valid_indices = np.where(ts_time1 &gt;= t0 &amp; ts_time1 &lt;= t1)\n        if valid_indices.size &gt; 0:\n            nl_tci1 = interp1(tci_t, tci, ts_time1[valid_indices])\n            nl_ts1 = interp1(nlts_t, nlts, ts_time1[valid_indices])\n            time1 = ts_time1[valid_indices]\n    else:\n        time1 = -1\n    if nyag2 &gt; 0:\n        indices2 += 1\n        ts_time2 = tci_time[indices2]\n        valid_indices = np.where(ts_time2 &gt;= t0 &amp; ts_time2 &lt;= t1)\n        if valid_indices.size &gt; 0:\n            nl_tci1 = interp1(tci_t, tci, ts_time2[valid_indices])\n            nl_ts1 = interp1(nlts_t, nlts, ts_time2[valid_indices])\n            time2 = ts_time2[valid_indices]\n    else:\n        time2 = -1\n    return nl_ts1, nl_ts2, nl_tci1, nl_tci2, time1, time2\n</code></pre>"},{"location":"shots-reference/#disruption_py.shots.cmod_shot.CModShot.efit_check","title":"<code>efit_check()</code>","text":""},{"location":"shots-reference/#disruption_py.shots.cmod_shot.CModShot.efit_check--todo-get-description-from-jinxiang","title":"TODO: Get description from Jinxiang","text":"Source code in <code>disruption_py\\shots\\cmod_shot.py</code> <pre><code>def efit_check(self):\n\"\"\"\n    # TODO: Get description from Jinxiang\n    \"\"\"\n    analysis_tree = Tree('analysis', self._shot_id)\n    values = analysis_tree.getNode(\n        '_lf=\\analysis::efit_aeqdsk:lflag,_l0=((sum(_lf,1) - _lf[*,20] - _lf[*,1])==0),_n=\\analysis::efit_fitout:nitera,(_l0 and (_n&gt;4))').getData().data()\n    valid_indices = np.nonzero(values)\n    times = analysis_tree.getNode('_lf').getData().dim_of(0)\n    return valid_indices, times[valid_indices]\n</code></pre>"},{"location":"shots-reference/#disruption_py.shots.cmod_shot.CModShot.integrate_ts_tci","title":"<code>integrate_ts_tci(nlnum)</code>","text":"<p>Integrate Thomson electron density measurement to the line integrated electron density for comparison with two color interferometer (TCI) measurement results</p> Source code in <code>disruption_py\\shots\\cmod_shot.py</code> <pre><code>def integrate_ts_tci(self, nlnum):\n\"\"\"\n    Integrate Thomson electron density measurement to the line integrated electron density for comparison with two color interferometer (TCI) measurement results\n    \"\"\"\n    core_mult = 1.0\n    edge_mult = 1.0\n    nlts = 1e32\n    nlts_t = 1e32\n    t, z, n_e, n_e_sig = self.map_ts2tci(nlnum)\n    if z[0, 0] == 1e32:\n        return None, None  # TODO: Log and maybe return nan arrs\n    nts = len(t)\n    nlts_t = t\n    nlts = np.full(t.shape, np.nan)\n    for i in range(len(nts)):\n        ind = np.where(np.abs(z[i, :]) &lt; 0.5 &amp; n_e[i, :] &gt;\n                       0 &amp; n_e[i, :] &lt; 1e21 &amp; n_e[i, :]/n_e_sig[i, :] &gt; 2)\n        if len(ind) &lt; 3:\n            nlts[i] = 0\n        else:\n            x = z[i, ind]\n            y = n_e[i, ind]\n            values_uniq, ind_uniq = np.unique(x, return_index=True)\n            y = y[ind_uniq]\n            nlts[i] = np.trapz(y, x)\n    return nlts, nlts_t\n</code></pre>"},{"location":"shots-reference/#d3d","title":"D3D","text":"<p>         Bases: <code>Shot</code></p> Source code in <code>disruption_py\\shots\\d3d_shot.py</code> <pre><code>class D3DShot(Shot):\n    # Tokamak Variables\n    nominal_flattop_radius = 0.59\n    # EFIT Variables\n    efit_cols = {'beta_n': r'\\efit_a_eqdsk:betan', 'beta_p': r'\\efit_a_eqdsk:betap', 'kappa': r'\\efit_a_eqdsk:kappa', 'li': r'\\efit_a_eqdsk:li', 'upper_gap': r'\\efit_a_eqdsk:gaptop', 'lower_gap': r'\\efit_a_eqdsk:gapbot',\n                 'q0': r'\\efit_a_eqdsk:q0', 'qstar': r'\\efit_a_eqdsk:qstar', 'q95': r'\\efit_a_eqdsk:q95', 'Wmhd': r'\\efit_a_eqdsk:wmhd', 'chisq': r'\\efit_a_eqdsk:chisq'}\n    # 'v_loop_efit': ,r'\\efit_a_eqdsk:vsurf', 'bt0': r'\\efit_a_eqdsk:bt0'\n    efit_derivs = {'beta_p': 'dbetap_dt', 'li': 'dli_dt', 'Wmhd': 'dWmhd_dt'}\n    rt_efit_cols = {'beta_p_RT': r'\\efit_a_eqdsk:betap', 'li_RT': r'\\efit_a_eqdsk:li',\n                    'q95_RT': r'\\efit_a_eqdsk:q95', 'Wmhd_RT': r'\\efit_a_eqdsk:wmhd', 'chisq': r'\\efit_a_eqdsk:chisq'}\n    # 'v_loop_efit_RT': r'\\efit_a_eqdsk:vsurf',\n\n    # Disruption Variables\n    dt_before_disruption = 0.002\n    duration_before_disruption = 0.10\n\n    def __init__(self, shot_id, efit_tree_name, data=None, times=None, disruption_time=None, override_cols=True, **kwargs):\n        super().__init__(shot_id, data)\n        self._times = times\n        self.conn = MDSplus.Connection('atlas.gat.com')\n        self.efit_tree_name = str(efit_tree_name)\n        self.disruption_time = disruption_time\n        self.disrupted = self.disruption_time is not None\n        self.override_cols = override_cols\n        self.data = data\n        timebase_signal = kwargs.pop('timebase_signal', None)\n        populate = kwargs.pop('populate', 'default')\n        if self.data is not None and self._times is None:\n            try:\n                self._times = self.data['time'].to_numpy()\n                # Check if the timebase is in ms instead of s\n                if self._times[-1] &gt; D3D_MAX_SHOT_TIME:\n                    self._times /= 1000  # [ms] -&gt; [s]\n            except KeyError as e:\n                self.logger.warning(\n                    f\"[Shot {self._shot_id}]:Shot constructor was passed data but no timebase.\")\n                self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n                self._times = self.get_timebase(timebase_signal, **kwargs)\n        if self._times is None:\n            self._times = self.get_timebase(timebase_signal, **kwargs)\n        if populate == 'l_mode':\n            self._populate_l_mode_data()\n        else:\n            self._populate_shot_data(data is not None)\n\n    def _populate_l_mode_data(self):\n        self.data = pd.concat([self.get_efit_parameters(), self.get_density_parameters(\n        ), self.get_peaking_factors(), self.get_kappa_area(), self.get_time_until_disrupt()], axis=1)\n        self.data['time'] = self._times\n        self.data['shot'] = self._shot_id\n\n    def _populate_shot_data(self, already_populated=False):\n        local_data = pd.concat([self.get_efit_parameters(), self.get_rt_efit_parameters(), self.get_density_parameters(), self.get_rt_density_parameters(), self.get_ip_parameters(\n        ), self.get_rt_ip_parameters(), self.get_power_parameters(), self.get_z_parameters(), self.get_zeff_parameters(), self.get_shape_parameters(), self.get_kappa_area(), self.get_peaking_factors(), self.get_time_until_disrupt()], axis=1)\n        local_data = local_data.loc[:, ~local_data.columns.duplicated()]\n        if not already_populated:\n            self.data = local_data\n            self.data['time'] = self._times\n            self.data['shot'] = self._shot_id\n\n    def get_timebase(self, timebase_signal, **kwargs):\n        if timebase_signal == None or timebase_signal == 'disruption_timebase':\n            minimum_ip = kwargs.get('minimum_ip', 400.e3)\n            minimum_duration = kwargs.get('minimum_duration', 0.1)\n            return self.get_disruption_timebase(minimum_ip, minimum_duration)\n        elif timebase_signal == 'ip':\n            _, ip_time = self._get_signal(\n                f\"ptdata('ip', {self._shot_id})\", interpolate=False)\n            return ip_time\n        elif timebase_signal == 'flattop':\n            _, ip_time = self._get_signal(\n                f\"ptdata('ip', {self._shot_id})\", interpolate=False)\n            return self.get_flattop_timebase(ip_time)\n        else:\n            raise NotImplementedError(\n                \"Only 'disruption_timebase' and 'ip' are supported for timebase_signal.\")\n\n    def get_disruption_timebase(self, minimum_ip=400.e3, minimum_duration=0.1):\n        self.conn.openTree('d3d', self._shot_id)\n        raw_ip, ip_time = self._get_signal(\n            f\"ptdata('ip', {self._shot_id})\", interpolate=False)\n        baseline = np.mean(raw_ip[0:10])\n        ip = raw_ip - baseline\n        duration, ip_max = self.get_end_of_shot(ip, ip_time, 100e3)\n        if duration &lt; minimum_duration or np.abs(ip_max) &lt; minimum_ip:\n            raise NotImplementedError()\n        times = np.arange(0.100, duration+0.025, 0.025)\n        if self.disrupted:\n            additional_times = np.arange(\n                self.disruption_time-self.duration_before_disruption, self.disruption_time + self.dt_before_disruption, self.dt_before_disruption)\n            times = times[np.where(times &lt; (self.disruption_time -\n                                            self.duration_before_disruption))]\n            times = np.concatenate((times, additional_times))\n        else:\n            ip_start = np.argmax(ip_time &lt;= .1)\n            ip_end = np.argmax(raw_ip[ip_start:] &lt;= 100000) + ip_start\n            return ip_time[ip_start:ip_end]  # [ms] -&gt; [s]\n        return times\n\n    def get_end_of_shot(self, signal, signal_time, threshold=1.e5):\n        duration = 0\n        signal_max = 0\n        if threshold &lt; 0:\n            raise Warning(\"Threshold is negative.\")\n        base_indices = np.where(signal_time &lt;= 0.0)\n        if len(base_indices) &gt; 0:\n            baseline = np.mean(signal[base_indices])\n        else:\n            baseline = 0\n        signal = signal - baseline\n        # Check if there was a finite signal otherwise consider the shot a \"no plasma\" shot\n        finite_indices = np.where(\n            (signal_time &gt;= 0.0) &amp; (np.abs(signal) &gt; threshold))\n        if len(finite_indices) == 0:\n            return duration, signal_max\n        else:\n            dt = np.diff(signal_time)\n            duration = np.sum(dt[finite_indices[:-1]])\n            if duration &lt; 0.1:  # Assuming &lt; 100 ms is not a bona fide plasma\n                duration = 0\n                return duration, signal_max\n        polarity = np.sign(\n            np.trapz(signal[finite_indices], signal_time[finite_indices]))\n        polarized_signal = polarity * signal\n        valid_indices = np.where(\n            (polarized_signal &gt;= threshold) &amp; (signal_time &gt; 0.0))\n        duration = signal_time[np.max(valid_indices)]\n        if len(valid_indices) == signal_time.size:\n            duration = - duration\n        signal_max = np.max(polarized_signal)*polarity\n        return duration, signal_max\n\n    def get_flattop_timebase(self, times):\n        # time_until_disrupt = self.disruption_time - times\n        # time_until_disrupt[time_until_disrupt &lt; 0] = np.nan\n        # indices_no_disrupt = np.where(np.isnan(time_until_disrupt))\n        # indices_disrupt = np.where(~np.isnan(time_until_disrupt))\n        try:\n            t_ip_prog = self.conn.get(\n                f\"dim_of(ptdata('iptipp', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            ip_prog = self.conn.get(\n                f\"ptdata('iptipp', {self._shot_id})\").data()  # [A]\n            polarity = np.unique(self.conn.get(\n                f\"ptdata('iptdirect', {self._shot_id})\").data())\n            if len(polarity) &gt; 1:\n                self.logger.info(\n                    f\"[Shot {self._shot_id}]:Polarity of Ip target is not constant. Using value at first timestep.\")\n                self.logger.debug(\n                    f\"[Shot {self._shot_id}]: Polarity array {polarity}\")\n                polarity = polarity[0]\n            ip_prog = ip_prog * polarity\n            dipprog_dt = np.gradient(ip_prog, t_ip_prog)\n            ip_prog = interp1(t_ip_prog, ip_prog, times, 'linear')\n            dipprog_dt = interp1(t_ip_prog, dipprog_dt, times, 'linear')\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get programmed plasma current parameters\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        epsoff = self.conn.get(f\"ptdata('epsoff', {self._shot_id})\").data()\n        t_epsoff = self.conn.get(\n            f\"dim_of(ptdata('epsoff', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n        t_epsoff += .001  # Avoid problem with simultaneity of epsoff being triggered exactly on the last time sample\n        epsoff = interp1(t_epsoff, epsoff, times, 'linear')\n        railed_indices = np.where(np.abs(epsoff) &gt; .5)\n        power_supply_railed = np.zeros(len(times))\n        power_supply_railed[railed_indices] = 1\n        indices_flattop = np.where((np.abs(dipprog_dt) &lt;= 2.e3) &amp; (\n            np.abs(ip_prog) &gt; 100e3) &amp; (power_supply_railed != 1))\n        return times[indices_flattop]\n\n    def get_time_until_disrupt(self):\n        if self.disrupted:\n            return pd.DataFrame({'time_until_disrupt': self.disruption_time - self._times})\n        return pd.DataFrame({'time_until_disrupt': np.full(self._times.size, np.nan)})\n\n    def get_efit_parameters(self):\n        self.conn.openTree(self.efit_tree_name, self._shot_id)\n        efit_data = {k: self.conn.get(v).data()\n                     for k, v in self.efit_cols.items()}\n        efit_time = self.conn.get(\n            r'\\efit_a_eqdsk:atime').data()/1.e3  # [ms] -&gt; [s]\n        if self._times is None:\n            self._times = efit_time\n        # EFIT reconstructions are sometimes invalid, particularly when very close\n        # to a disruption.  There are a number of EFIT parameters that can indicate\n        # invalid reconstructions, such as 'terror' and 'chisq'.  Here we use\n        # 'chisq' to determine which time slices should be excluded from our\n        # disruption warning database.\n        invalid_indices = np.where(efit_data['chisq'] &gt; 50)\n        del efit_data['chisq']\n        for param in efit_data:\n            efit_data[param][invalid_indices] = np.nan\n        for param in self.efit_derivs:\n            efit_data[self.efit_derivs[param]] = np.gradient(\n                efit_data[param], efit_time)\n        if not np.array_equal(self._times, efit_time):\n            for param in efit_data:\n                efit_data[param] = interp1(\n                    efit_time, efit_data[param], self._times)\n        return pd.DataFrame(efit_data)\n\n    def get_rt_efit_parameters(self):\n        self.conn.openTree('efitrt1', self._shot_id)\n        efit_data = {k: self.conn.get(v).data()\n                     for k, v in self.rt_efit_cols.items()}\n        efit_time = self.conn.get(\n            r'\\efit_a_eqdsk:atime').data()/1.e3  # [ms] -&gt; [s]\n        # EFIT reconstructions are sometimes invalid, particularly when very close\n        # to a disruption.  There are a number of EFIT parameters that can indicate\n        # invalid reconstructions, such as 'terror' and 'chisq'.  Here we use\n        # 'chisq' to determine which time slices should be excluded from our\n        # disruption warning database.\n        invalid_indices = np.where(efit_data['chisq'] &gt; 50)\n        del efit_data['chisq']\n        for param in efit_data:\n            efit_data[param][invalid_indices] = np.nan\n        if not np.array_equal(self._times, efit_time):\n            for param in efit_data:\n                efit_data[param] = interp1(\n                    efit_time, efit_data[param], self._times)\n        return pd.DataFrame(efit_data)\n\n    def get_H_parameters(self):\n        self.conn.openTree('transport', self._shot_id)\n        try:\n            h_98, _ = self._get_signal(r'\\H_THH98Y2')\n        except ValueError as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]: Failed to get H98 signal. Returning NaNs.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]: {e}\")\n            h_98 = np.full(self._times.size, np.nan)\n        self.conn.openTree('d3d', self._shot_id)\n        try:\n            h_alpha, _ = self._get_signal(r'\\fs04')\n        except ValueError as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]: Failed to get H_alpha signal. Returning NaNs.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]: {e}\")\n            h_alpha = np.full(self._times.size, np.nan)\n        return pd.DataFrame({'H98': h_98, 'H_alpha': h_alpha})\n\n    def get_power_parameters(self):\n        self.conn.openTree('d3d', self._shot_id)\n        # Get neutral beam injected power\n        try:\n            p_nbi, t_nbi = self._get_signal(\n                r'\\d3d::top.nb:pinj', interpolate=False)\n            p_nbi = p_nbi.astype(np.float64)\n            p_nbi *= 1.e3  # [KW] -&gt; [W]\n            if len(t_nbi) &gt; 2:\n                p_nbi = interp1(t_nbi, p_nbi, self._times,\n                                'linear', bounds_error=False, fill_value=0.)\n            else:\n                self.logger.info(\n                    f\"[Shot {self._shot_id}]:No NBI power data found in this shot.\")\n                p_nbi = np.zeros(len(self._times))\n        except MdsException as e:\n            p_nbi = np.zeros(len(self._times))\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to open NBI node\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        # Get electron cycholotrn heating (ECH) power. It's poitn data, so it's not stored in an MDSplus tree\n        self.conn.openTree('rf', self._shot_id)\n        try:\n            p_ech, t_ech = self._get_signal(\n                r'\\top.ech.total:echpwrc', interpolate=False)\n            if len(t_ech) &gt; 2:\n                p_ech = interp1(t_ech, p_ech, self._times,\n                                'linear', bounds_error=False, fill_value=0.)\n            else:\n                self.logger.info(\n                    f\"[Shot {self._shot_id}]:No ECH power data found in this shot. Setting to zeros\")\n                p_ech = np.zeros(len(self._times))\n        except MdsException as e:\n            p_ech = np.zeros(len(self._times))\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to open ECH node. Setting to zeros\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        # Get ohmic power and loop voltage\n        p_ohm, v_loop = self.get_ohmic_parameters()\n        # Radiated power\n        # We had planned to use the standard signal r'\\bolom::prad_tot' for this\n        # parameter.  However, the processing involved in calculating \\prad_tot\n        # from the arrays of bolometry channels involves non-causal filtering with\n        # a 50 ms window.  This is not acceptable for our purposes.  Tony Leonard\n        # provided us with the two IDL routines that are used to do the automatic\n        # processing that generates the \\prad_tot signal in the tree (getbolo.pro\n        # and powers.pro).  I converted them into Matlab routines, and modified the\n        # analysis so that the smoothing is causal, and uses a shorter window.\n        smoothing_window = 0.010  # [s]\n        try:\n            self.conn.openTree(\"bolom\", self._shot_id)\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to open bolom tree.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        bol_prm, _ = self._get_signal(r'\\bol_prm', interpolate=False)\n        lower_channels = [f\"bol_u{i+1:02d}_v\" for i in range(24)]\n        upper_channels = [f\"bol_l{i+1:02d}_v\" for i in range(24)]\n        bol_channels = lower_channels + upper_channels\n        bol_signals = []\n        bol_times = []\n        for i in range(48):\n            bol_signal, bol_time = self._get_signal(\n                fr\"\\top.raw:{bol_channels[i]}\", interpolate=False)\n            bol_signals.append(bol_signal)\n            bol_times.append(bol_time)\n        a_struct = get_bolo(self._shot_id, bol_channels,\n                            bol_prm, bol_signals, bol_times)\n        ier = 0\n        for j in range(48):\n            # TODO: Ask about how many valid channels are needed for proper calculation\n            if a_struct.channels[j].ier == 1:\n                ier = 1\n                p_rad = np.full(len(self._times), np.nan)\n                break\n        if ier == 0:\n            b_struct = power(a_struct)\n            p_rad = b_struct.pwrmix  # [W]\n            p_rad = interp1(a_struct.time, p_rad, self._times, 'linear')\n\n        # Remove any negative values from the power data\n        p_rad[np.isinf(p_rad)] = np.nan\n        p_rad[p_rad &lt; 0] = 0\n        p_nbi[p_nbi &lt; 0] = 0\n        p_ech[p_ech &lt; 0] = 0\n\n        p_input = p_rad + p_nbi + p_ech  # [W]\n        rad_fraction = p_rad/p_input\n        rad_fraction[np.isinf(rad_fraction)] = np.nan\n\n        # Computer P_sol, defined as P_in - P_rad\n        p_sol = p_input - p_rad\n\n        return pd.DataFrame({'p_rad': p_rad, 'p_nbi': p_nbi, 'p_ech': p_ech, 'p_ohm': p_ohm, 'radiated_fraction': rad_fraction, 'v_loop': v_loop})\n\n    def get_ohmic_parameters(self):\n        self.conn.openTree('d3d', self._shot_id)\n        # Get edge loop voltage and smooth it a bit with a median filter\n        try:\n            v_loop, t_v_loop = self._get_signal(\n                f'ptdata(\"vloopb\", {self._shot_id})', interpolate=False)\n            v_loop = scipy.signal.medfilt(v_loop, 11)\n            v_loop = interp1(t_v_loop, v_loop, self._times, 'linear')\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to open VLOOPB node. Setting to NaN.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            v_loop = np.full(len(self._times), np.nan)\n            t_v_loop = v_loop.copy()\n       # Get plasma current\n        try:\n            ip = self.conn.get(f\"ptdata('ip', {self._shot_id})\").data()  # [A]\n            t_ip = self.conn.get(\n                f\"dim_of(ptdata('ip', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            # We choose a 20-point width for gsastd. This means a 10ms window for ip smoothing\n            dipdt_smoothed = gsastd(t_ip, ip, 1, 20, 3, 1, 0)\n            self.conn.openTree(self.efit_tree_name, self._shot_id)\n            li, t_li = self._get_signal(r'\\efit_a_eqdsk:li', interpolate=False)\n            chisq = self.conn.get(r'\\efit_a_eqdsk:chisq').data()\n            # Filter out invalid indices of efit reconstruction\n            invalid_indices = None  # TODO: Finish\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Unable to get plasma current data. p_ohm set to NaN.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            p_ohm = np.full(len(self._times), np.nan)\n            return pd.DataFrame({'p_ohm': p_ohm, 'v_loop': v_loop})\n        # [m] For simplicity, use fixed r_0 = 1.67 for DIII-D major radius\n        r_0 = 1.67\n        inductance = 4.*np.pi*r_0 * li/2  # [H]\n        inductance = interp1(t_li, inductance, self._times, 'linear')\n        ip = interp1(t_ip, ip, self._times, 'linear')\n        dipdt_smoothed = interp1(t_ip, dipdt_smoothed, self._times, 'linear')\n        v_inductive = inductance * dipdt_smoothed  # [V]\n        v_resistive = v_loop - v_inductive  # [V]\n        p_ohm = ip * v_resistive  # [W]\n        return pd.DataFrame({'p_ohm': p_ohm, 'v_loop': v_loop})\n\n    def get_density_parameters(self):\n        ne = np.full(len(self._times), np.nan)\n        g_f = ne.copy()\n        dne_dt = ne.copy()\n        self.conn.openTree(self.efit_tree_name, self._shot_id)\n        try:\n            t_ne = self.conn.get(\n                r'dim_of(\\density)').data()/1.e3  # [ms] -&gt; [s]\n            ne = self.conn.get(r'\\density').data()*1.e6  # [cm^3] -&gt; [m^3]\n            dne_dt = np.gradient(ne, t_ne)\n            # NOTE: t_ne has higher resolution than efit_time so t_ne[0] &lt; efit_time[0] because of rounding, meaning we need to allow extrapolation\n            ne = interp1(t_ne, ne, self._times, 'linear',\n                         bounds_error=False, fill_value='extrapolate')\n            dne_dt = interp1(t_ne, dne_dt, self._times, 'linear',\n                             bounds_error=False, fill_value='extrapolate')\n            t_ip = self.conn.get(\n                f\"dim_of(ptdata('ip', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            ip = self.conn.get(f\"ptdata('ip', {self._shot_id})\").data()  # [A]\n            ipsign = np.sign(np.sum(ip))\n            ip = interp1(t_ip, ip*ipsign, self._times, 'linear')\n            a_minor = self.conn.get(r'\\efit_a_eqdsk:aminor').data()  # [m]\n            t_a = self.conn.get(\n                r'\\efit_a_eqdsk:atime').data()/1.e3  # [ms] -&gt; [s]\n            a_minor = interp1(t_a, a_minor, self._times, 'linear')\n            with np.errstate(divide='ignore'):\n                n_g = ip/1.e6 / (np.pi*a_minor**2)  # [MA/m^2]\n                g_f = ne/1.e20 / n_g  # TODO: Fill in units\n        except MdsException as e:\n            # TODO: Confirm that there is a separate exception if ptdata name doesn't exist\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get some parameter\")\n            self.logger.debug(f\"[Shot {self._shot_id}]::{e}\")\n        return pd.DataFrame({'n_e': ne, 'Greenwald_fraction': g_f, 'dn_dt': dne_dt})\n\n    def get_rt_density_parameters(self):\n        ne_rt = np.full(len(self._times), np.nan)\n        g_f_rt = ne_rt.copy()\n        dne_dt_rt = ne_rt.copy()\n        try:\n            t_ne_rt = self.conn.get(\n                f\"dim_of(ptdata('dssdenest', {self._shot_id}))\").data()/1.e3  # [ms] to [s]\n            # [10^19 m^-3] -&gt; [m^-3]\n            ne_rt = self.conn.get(\n                f\"ptdata('dssdenest', {self._shot_id})\").data()*1.e19\n            dne_dt_rt = np.gradient(ne_rt, t_ne_rt)  # [m^-3/s]\n            ne_rt = interp1(t_ne_rt, ne_rt, self._times, 'linear')\n            dne_dt_rt = interp1(t_ne_rt, dne_dt_rt, self._times, 'linear')\n            try:\n                t_ip_rt = self.conn.get(\n                    f\"dim_of(ptdata('ipsip', {self._shot_id}))\").data()/1.e3  # [ms] to [s]\n                ip_rt = self.conn.get(\n                    f\"ptdata('ipsip', {self._shot_id})\").data()  # [MA]\n            except Exception as e:\n                t_ip_rt = self.conn.get(\n                    f\"dim_of(ptdata('ipspr15v', {self._shot_id}))\").data()/1.e3  # [ms] to [s]\n                ip_rt = self.conn.get(\n                    f\"ptdata('ipspr15v', {self._shot_id})\").data()  # [MA]\n            ip_sign = np.sign(np.sum(ip_rt))\n            ip = interp1(t_ip_rt, ip_rt*ip_sign, self._times, 'linear')\n            self.conn.openTree('efitrt1', self._shot_id)\n            a_minor_rt = self.conn.get(r'\\efit_a_eqdsk:aminor').data()  # [m]\n            t_a_rt = self.conn.get(\n                r'\\efit_a_eqdsk:atime').data()/1.e3  # [ms] -&gt; [s]\n            a_minor_rt = interp1(t_a_rt, a_minor_rt, self._times, 'linear')\n            with np.errstate(divide='ignore'):\n                n_g_rt = ip/1.e6 / (np.pi*a_minor_rt**2)  # [MA/m^2]\n                g_f_rt = ne_rt/1.e20 / n_g_rt  # TODO: Fill in units\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get some parameter\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        # ' dne_dt_RT': dne_dt_rt\n        return pd.DataFrame({'n_e_RT': ne_rt, 'Greenwald_fraction_RT': g_f_rt})\n\n    def get_ip_parameters(self):\n        self.conn.openTree('d3d', self._shot_id)\n        ip = np.full(len(self._times), np.nan)\n        ip_prog = np.full(len(self._times), np.nan)\n        ip_error = np.full(len(self._times), np.nan)\n        dip_dt = np.full(len(self._times), np.nan)\n        dipprog_dt = np.full(len(self._times), np.nan)\n        # Get measured plasma current parameters\n        try:\n            t_ip = self.conn.get(\n                f\"dim_of(ptdata('ip', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            ip = self.conn.get(f\"ptdata('ip', {self._shot_id})\").data()  # [A]\n            dip_dt = np.gradient(ip, t_ip)\n            ip = interp1(t_ip, ip, self._times, 'linear')\n            dip_dt = interp1(t_ip, dip_dt, self._times, 'linear')\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get measured plasma current parameters\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        # Get programmed plasma current parameters\n        try:\n            t_ip_prog = self.conn.get(\n                f\"dim_of(ptdata('iptipp', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            ip_prog = self.conn.get(\n                f\"ptdata('iptipp', {self._shot_id})\").data()  # [A]\n            polarity = np.unique(self.conn.get(\n                f\"ptdata('iptdirect', {self._shot_id})\").data())\n            if len(polarity) &gt; 1:\n                self.logger.info(\n                    f\"[Shot {self._shot_id}]:Polarity of Ip target is not constant. Using value at first timestep.\")\n                self.logger.debug(\n                    f\"[Shot {self._shot_id}]: Polarity array {polarity}\")\n                polarity = polarity[0]\n            ip_prog = ip_prog * polarity\n            dipprog_dt = np.gradient(ip_prog, t_ip_prog)\n            ip_prog = interp1(t_ip_prog, ip_prog, self._times, 'linear')\n            dipprog_dt = interp1(t_ip_prog, dipprog_dt, self._times, 'linear')\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get programmed plasma current parameters\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        # Now get the signal pointname 'ipimode'.  This PCS signal denotes whether\n        # or not PCS is actually feedback controlling the plasma current.  There\n        # are times when feedback of Ip is purposely turned off, such as during\n        # electron cyclotron current drive experiments.  Here is how to interpret\n        # the value of 'ipimode':\n        #  0: normal Ip feedback to E-coils supplies\n        #  3: almost normal Ip feedback, except that abs(Ip) &gt; 2.5 MA\n        #  Anything else: not in normal Ip feedback mode.  In this case, the\n        # 'ip_prog' signal is irrelevant, and therefore 'ip_error' is not defined.\n        try:\n            ipimode = self.conn.get(\n                f\"ptdata('ipimode', {self._shot_id})\").data()\n            t_ipimode = self.conn.get(\n                f\"dim_of(ptdata('ipimode', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            ipimode = interp1(t_ipimode, ipimode, self._times, 'linear')\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get ipimode signal. Setting to NaN.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            ipimode = np.full(len(self._times), np.nan)\n        feedback_on_indices = np.where((ipimode == 0) | (ipimode == 3))\n        ip_error[feedback_on_indices] = ip[feedback_on_indices] - \\\n            ip_prog[feedback_on_indices]\n        # Finally, get 'epsoff' to determine if/when the E-coil power supplies have railed\n        # Times at which power_supply_railed ~=0 (i.e. epsoff ~=0) mean that\n        # PCS feedback control of Ip is not being applied.  Therefore the\n        # 'ip_error' parameter is undefined for these times.\n        try:\n            epsoff = self.conn.get(f\"ptdata('epsoff', {self._shot_id})\").data()\n            t_epsoff = self.conn.get(\n                f\"dim_of(ptdata('epsoff', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            t_epsoff += .001  # Avoid problem with simultaneity of epsoff being triggered exactly on the last time sample\n            epsoff = interp1(t_epsoff, epsoff, self._times, 'linear')\n            railed_indices = np.where(np.abs(epsoff) &gt; .5)\n            power_supply_railed = np.zeros(len(self._times))\n            power_supply_railed[railed_indices] = 1\n            ip_error[railed_indices] = np.nan\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get epsoff signal. Setting to NaN.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            power_supply_railed = np.full(len(self._times), np.nan)\n        # 'ip_prog': ip_prog,\n        return pd.DataFrame({'ip': ip, 'ip_error': ip_error, 'dip_dt': dip_dt, 'dipprog_dt': dipprog_dt, 'power_supply_railed': power_supply_railed})\n\n    def get_rt_ip_parameters(self):\n        self.conn.openTree('d3d', self._shot_id)\n        ip_rt = np.full(len(self._times), np.nan)\n        ip_prog_rt = np.full(len(self._times), np.nan)\n        ip_error_rt = np.full(len(self._times), np.nan)\n        dip_dt_rt = np.full(len(self._times), np.nan)\n        dipprog_dt_rt = np.full(len(self._times), np.nan)\n        # Get measured plasma current parameters\n        try:\n            t_ip_rt = self.conn.get(\n                f\"dim_of(ptdata('ipsip', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            ip_rt = self.conn.get(\n                f\"ptdata('ipsip', {self._shot_id})\").data()*1.e6  # [MA] -&gt; [A]\n            dip_dt_rt = np.gradient(ip_rt, t_ip_rt)\n            ip_rt = interp1(t_ip_rt, ip_rt, self._times, 'linear')\n            dip_dt_rt = interp1(t_ip_rt, dip_dt_rt, self._times, 'linear')\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get measured plasma current parameters\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        # Get programmed plasma current parameters\n        try:\n            t_ip_prog_rt = self.conn.get(\n                f\"dim_of(ptdata('ipsiptargt', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            ip_prog_rt = self.conn.get(\n                f\"ptdata('ipsiptargt', {self._shot_id})\").data()*1.e6*.5  # [MA] -&gt; [A]\n            polarity = np.unique(self.conn.get(\n                f\"ptdata('iptdirect', {self._shot_id})\").data())\n            if len(polarity) &gt; 1:\n                self.logger.info(\n                    f\"[Shot {self._shot_id}]:Polarity of Ip target is not constant. Setting to first value in array.\")\n                self.logger.debug(\n                    f\"[Shot {self._shot_id}]: Polarity array: {polarity}\")\n                polarity = polarity[0]\n            ip_prog_rt = ip_prog_rt * polarity\n            dipprog_dt_rt = np.gradient(ip_prog_rt, t_ip_prog_rt)\n            ip_prog_rt = interp1(t_ip_prog_rt, ip_prog_rt,\n                                 self._times, 'linear')\n            dipprog_dt_rt = interp1(\n                t_ip_prog_rt, dipprog_dt_rt, self._times, 'linear')\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get programmed plasma current parameters\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        try:\n            t_ip_error_rt = self.conn.get(\n                f\"dim_of(ptdata('ipeecoil', {self._shot_id}))\").data()/1.e3  # [ms] to [s]\n            ip_error_rt = self.conn.get(\n                f\"ptdata('ipeecoil', {self._shot_id})\").data()*1.e6*.5  # [MA] -&gt; [A]\n            ip_error_rt = interp1(\n                t_ip_error_rt, ip_error_rt, self._times, 'linear')\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get ipeecoil signal. Setting to NaN.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        # Now get the signal pointname 'ipimode'.  This PCS signal denotes whether\n        # or not PCS is actually feedback controlling the plasma current.  There\n        # are times when feedback of Ip is purposely turned off, such as during\n        # electron cyclotron current drive experiments.  Here is how to interpret\n        # the value of 'ipimode':\n        #  0: normal Ip feedback to E-coils supplies\n        #  3: almost normal Ip feedback, except that abs(Ip) &gt; 2.5 MA\n        #  Anything else: not in normal Ip feedback mode.  In this case, the\n        # 'ip_prog' signal is irrelevant, and therefore 'ip_error' is not defined.\n        try:\n            ipimode = self.conn.get(\n                f\"ptdata('ipimode', {self._shot_id})\").data()\n            t_ipimode = self.conn.get(\n                f\"dim_of(ptdata('ipimode', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            ipimode = interp1(t_ipimode, ipimode, self._times, 'linear')\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get ipimode signal. Setting to NaN.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            ipimode = np.full(len(self._times), np.nan)\n        feedback_off_indices = np.where((ipimode != 0) &amp; (ipimode == 3))\n        ip_error_rt[feedback_off_indices] = np.nan\n        # Finally, get 'epsoff' to determine if/when the E-coil power supplies have railed\n        # Times at which power_supply_railed ~=0 (i.e. epsoff ~=0) mean that\n        # PCS feedback control of Ip is not being applied.  Therefore the\n        # 'ip_error' parameter is undefined for these times.\n        try:\n            epsoff = self.conn.get(f\"ptdata('epsoff', {self._shot_id})\").data()\n            t_epsoff = self.conn.get(\n                f\"dim_of(ptdata('epsoff', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            t_epsoff += .001  # Avoid problem with simultaneity of epsoff being triggered exactly on the last time sample\n            epsoff = interp1(t_epsoff, epsoff, self._times, 'linear')\n            railed_indices = np.where(np.abs(epsoff) &gt; .5)\n            power_supply_railed = np.zeros(len(self._times))\n            power_supply_railed[railed_indices] = 1\n            ip_error_rt[railed_indices] = np.nan\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get epsoff signal. power_supply_railed will be NaN.\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            power_supply_railed = np.full(len(self._times), np.nan)\n        # 'dip_dt_RT': dip_dt_rt,\n        return pd.DataFrame({'ip_RT': ip_rt, 'ip_error_RT': ip_error_rt, 'dipprog_dt_RT': dipprog_dt_rt, 'power_supply_railed': power_supply_railed})\n\n    def get_z_parameters(self):\n\"\"\"\n        On DIII-D the plasma control system uses isoflux\n        control to control the plasma shape and position.  It does\n        NOT use zcur control.  Therefore, the PCS does not have a\n        programmed vertical position.  This this routine will now\n        always return an arrays of NaN for z_prog, z_error, and\n        z_error_norm.\n        \"\"\"\n        z_cur = np.full(len(self._times), np.nan)\n        z_cur_norm = np.full(len(self._times), np.nan)\n        z_prog = np.full(len(self._times), np.nan)\n        z_error = np.full(len(self._times), np.nan)\n        z_error_norm = np.full(len(self._times), np.nan)\n        self.conn.openTree('d3d', self._shot_id)\n        try:\n            t_z_cur = self.conn.get(\n                f\"dim_of(ptdata('vpszp', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n            z_cur = self.conn.get(\n                f\"ptdata('vpszp', {self._shot_id})\").data()/1.e2  # [cm] -&gt; [m]\n            z_cur = interp1(t_z_cur, z_cur, self._times, 'linear')\n            self.conn.openTree(self.efit_tree_name, self._shot_id)\n            try:\n                t_a = self.conn.get(\n                    r'\\efit_a_eqdsk:atime').data()/1.e3  # [ms] -&gt; [s]\n                a_minor = self.conn.get(r'\\efit_a_eqdsk:aminor').data()  # [m]\n                chisq = self.conn.get(r'\\efit_a_eqdsk:chisq').data()\n                invalid_indices = np.where(chisq &gt; 50)\n                a_minor[invalid_indices] = np.nan\n                a_minor = interp1(t_a, a_minor, self._times, 'linear')\n                z_cur_norm = z_cur/a_minor\n            except MdsException as e:\n                self.logger.info(\n                    f\"[Shot {self._shot_id}]:Failed to get efit parameters\")\n                self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n                z_cur_norm = z_cur / self.nominal_flattop_radius\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get vpszp signal\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        return pd.DataFrame({'zcur': z_cur, 'zcur_normalized': z_cur_norm, 'z_prog': z_prog, 'z_error': z_error, 'z_error_normalized': z_error_norm})\n\n    def get_n1_bradial_parameters(self):\n        # The following shots are missing bradial calculations in MDSplus and must be loaded from a separate datafile\n        if self._shot_id &gt;= 176030 and self._shot_id &lt;= 176912:\n            # TODO: Move to a folder like \"/fusion/projects/disruption_warning/data\"\n            filename = '/fusion/projects/disruption_warning/matlab_programs/recalc.nc'\n            ncid = nc.Dataset(filename, 'r')\n            brad = ncid.variables['dusbradial_calculated'][:]\n            t_n1 = ncid.variables['times'][:]*1.e-3  # [ms] -&gt; [s]\n            shots = ncid.variables['shots'][:]\n            shot_indices = np.where(shots == self._shot_id)\n            if len(shot_indices) == 1:\n                dusbradial = brad[shot_indices, :]*1.e-4  # [T]\n            else:\n                self.logger.info(\n                    f\"Shot {self._shot_id} not found in {filename}.  Returning NaN.\")\n                dusbradial = np.full(len(self._times), np.nan)\n            ncid.close()\n        # Check ONFR than DUD(legacy)\n        else:\n            try:\n                dusbradial, t_n1 = self._get_signal(\n                    f\"ptdata('onsbradial',{self._shot_id})\")*1.e-4  # [T]\n            except MdsException as e:\n                self.logger.debug(f\"[Shot {self._shot_id}]: {e}\")\n                try:\n                    dusbradial, t_n1 = self._get_signal(\n                        f\"ptdata('dusbradial',{self._shot_id})\")*1.e-4  # [T]\n                except MdsException as e:\n                    self.logger.info(\n                        f\"[Shot {self._shot_id}]:Failed to get n1 bradial signal. Returning NaN.\")\n                    self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n                    n_equal_1_mode = np.full(len(self._times), np.nan)\n                    n_equal_1_normalized = np.full(len(self._times), np.nan)\n                    return pd.DataFrame({'n_equal_1_normalized': n_equal_1_normalized, 'n_equal_1_mode': n_equal_1_mode})\n        n_equal_1_mode = interp1(dusbradial, t_n1, self._times)\n        # Get toroidal field Btor\n        b_tor, _ = self._get_signal(\n            \"ptdata('bt',{self._shot_id})\")  # [T]\n        n_equal_1_normalized = n_equal_1_mode/b_tor\n        return pd.DataFrame({'n_equal_1_normalized': n_equal_1_normalized, 'n_equal_1_mode': n_equal_1_mode})\n\n    def get_n1rms_parameters(self):\n        self.conn.openTree('d3d', self._shot_id)\n        n1rms, t_n1rms = self._get_signal(r'\\n1rms', interpolate=False)\n        n1rms *= 1.e-4  # Gauss -&gt; Tesla\n        n1rms = interp1(t_n1rms, n1rms, self._times)\n        b_tor = self._get_signal(\n            \"ptdata('bt',{self._shot_id})\")  # [T]\n        n1rms_norm = n1rms / np.abs(b_tor)\n        return pd.DataFrame({'n1rms': n1rms, 'n1rms_normalized': n1rms_norm})\n\n    # TODO: Need to test and unblock recalculating peaking factors\n    # By default get_peaking_factors should grab the data from MDSPlus as opposed to recalculate. See DPP v4 document for details:\n    # https://docs.google.com/document/d/1R7fI7mCOkMQGt8xX2nS6ZmNNkcyvPQ7NmBfRPICFaFs/edit?usp=sharing\n    def get_peaking_factors(self):\n        ts_data_type = 'blessed'  # either 'blessed', 'unblessed', or 'ptdata'\n        # metric to use for core/edge binning (either 'psin' or 'rhovn')\n        ts_radius = 'rhovn'\n        # ts_radius value defining boundary of 'core' region (between 0 and 1)\n        ts_core_margin = 0.3\n        # All data outside this range excluded. For example, psin=0 at magnetic axis and 1 at separatrix.\n        ts_radial_range = (0, 1)\n        # set to true to interpolate ts_channel data onto equispaced radial grid\n        ts_equispaced = False\n        # fan to use for P_rad peaking factors (either 'lower', 'upper', or 'custom')\n        bolometer_fan = 'custom'\n        # array of bolometer fan channel numbers covering divertor (upper fan: 1-&gt;24, lower fan: 25:48)\n        div_channels = np.arange(3, 8)+24\n        # time window for filtering raw bolometer signal in [ms]\n        smoothing_window = 40\n        p_rad_core_def = 0.06  # percentage of DIII-D veritcal extent defining the core margin\n        # 'brightness'; % either 'brightness' or 'power' ('z')\n        p_rad_metric = 'brightness'\n        # Ts options\n        ts_options = ['combined', 'core', 'tangential']\n        # vertical range of the DIII-D cross section in meters\n        vert_range = 3\n        te_pf = np.full(len(self._times), np.nan)\n        ne_pf = np.full(len(self._times), np.nan)\n        rad_cva = np.full(len(self._times), np.nan)\n        rad_xdiv = np.full(len(self._times), np.nan)\n        try:\n            rad_cva = self._get_signal(\n                f\"ptdata('dpsradcva', {self._shot_id})\")\n            rad_xdiv = self._get_signal(\n                f\"ptdata('dpsradxdiv', {self._shot_id})\")\n        except MdsException as e:\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get CVA and XDIV from MDSPlus. Calculating locally, results may be inaccurate.\")\n            rad_cva = np.full(len(self._times), np.nan)\n            rad_xdiv = np.full(len(self._times), np.nan)\n        try:\n            ts = self._get_ne_te()\n            for option in ts_options:\n                if option in ts:\n                    ts = ts[option]\n            efit_dict = self._get_efit_dict()\n            ts['psin'], ts['rho_vn'] = efit_rz_interp(ts, efit_dict)\n        except Exception as e:\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            ts = 0\n        try:\n            p_rad = self._get_p_rad()\n        except Exception as e:\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            p_rad = 0\n        if p_rad == 0 and ts == 0:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Both TS and bolometer data missing for shot #{self._shot_id}\")\n        if ts != 0:\n            # Drop data outside of valid range\n            invalid_indices = np.where((ts[ts_radius] &lt; ts_radial_range[0]) | (\n                ts[ts_radius] &gt; ts_radial_range[1]))\n            ts['te'][invalid_indices] = np.nan\n            ts['ne'][invalid_indices] = np.nan\n            ts['te'][np.isnan(ts[ts_radius])] = np.nan\n            ts['ne'][np.isnan(ts[ts_radius])] = np.nan\n            if ts_equispaced:\n                raise NotImplementedError(\n                    \"Equispaced is currently assumed to be false\")  # TODO\n            # Find core bin for Thomson and calculate Te, ne peaking factors\n            core_mask = ts[ts_radius] &lt; ts_core_margin\n            te_core = ts['te']\n            te_core[~core_mask] = np.nan\n            ne_core = ts['ne']\n            ne_core[~core_mask] = np.nan\n            te_pf = np.nanmean(te_core, axis=1)/np.nanmean(ts['te'], axis=1)\n            ne_pf = np.nanmean(ne_core, axis=1)/np.nanmean(ts['ne'], axis=1)\n            # Calculate Prad CVA, X-DIV Peaking Factors\n            # # Interpolate zmaxis and channel intersects x onto the bolometer timebase\n            z_m_axis = interp1(efit_dict['time'],\n                               efit_dict['zmaxis'], ts['time'])\n            z_m_axis = np.repeat(\n                z_m_axis[:, np.newaxis], p_rad['x'].shape[1], axis=1)\n            p_rad['xinterp'] = interp1(p_rad['xtime'], p_rad['x'], p_rad['t'])\n            # # Determine the bolometer channels falling in the 'core' bin\n            core_indices = (p_rad['xinterp'] &lt; z_m_axis + p_rad_core_def*vert_range) &amp; (\n                p_rad['xinterp'] &gt; z_m_axis - p_rad_core_def*vert_range)\n            # # Designate the divertor bin and find all 'other' channels not in that bin\n            div_indices = np.searchsorted(p_rad['ch_avail'], div_channels)\n            other_indices = ~div_indices\n            # # Grab p_rad measurements for each needed set of channels\n            p_rad_core = p_rad[p_rad_metric]\n            p_rad_all_but_core = p_rad_core.copy()\n            # QUESTION: Why fill with nans for core but just keep valid indices for divertor\n            p_rad_core[~core_indices] = np.nan\n            p_rad_all_but_core[core_indices] = np.nan\n            p_rad_div = p_rad[p_rad_metric][div_indices, :]\n            p_rad_all_but_div = p_rad[p_rad_metric][other_indices, :]\n            # # Calculate the peaking factors\n            rad_cva = np.nanmean(p_rad_core, axis=0) / \\\n                np.nanmean(p_rad_all_but_div, axis=0)\n            rad_xdiv = np.nanmean(p_rad_div, axis=0) / \\\n                np.nanmean(p_rad_all_but_core, axis=0)\n            rad_cva = interp1(p_rad['t'], rad_cva, self._times)\n            rad_xdiv = interp1(p_rad['t'], rad_xdiv, self._times)\n        return pd.DataFrame({'te_pf': te_pf, 'ne_pf': ne_pf, 'rad_cva': rad_cva, 'rad_xdiv': rad_xdiv})\n\n    # TODO: Finish implementing just in case\n    def _efit_map_rz_to_rho_original(self, ts_dict, efit_dict):\n        slices = np.zeros(ts_dict['time'].shape)\n        # If thomson starts before EFIT (often does), then use the first valid EFIT slice for early Thomson data.\n        early_indices = np.where(ts_dict['time'] &lt; efit_dict['time'])\n        if len(early_indices[0]) &gt; 0:\n            slices[early_indices] = 1\n            first_ts = early_indices[0][-1]\n        else:\n            first_ts = 0\n        # If Thomson ends after EFIT (also often happens), then use the last valid EFIT slice for late Thomson data.\n        late_indices = np.where(ts_dict['time'] &gt;= efit_dict['time'])\n        if len(late_indices[0]) &gt; 0:\n            slices[late_indices] = len(efit_dict['time'])\n            last_ts = late_indices[0][0] - 1\n        else:\n            last_ts = len(ts_dict['time']) - 1\n        diag_slices = np.arange(first_ts, last_ts+1, 1)\n        # Acquire list of diag time slices w/in EFIT time range; Should find closest EFIT for each one\n        for i in diag_slices:\n            slices[i] = np.argmin(\n                np.abs(efit_dict['time'] - ts_dict['time'][i]))\n        # Interpolate EFIT data onto Thomson time slices\n        psin_diag_arr = np.zeros((len(efit_dict['time']), len(ts_dict['z'])))\n        for r in np.unique(ts_dict['r']):\n            dr = r - efit_dict['r']\n            # Find closet EFIT R on the left and right\n            right = np.where(efit_dict['r'] &gt; r, 1)\n            left = right - 1\n            if efit_dict['r'][right] == r:\n                psin_slice = np.squeeze(efit_dict['psin'][:, right, :])\n\n    def get_core_edge_vals(self):\n        ##################################################\n        # Settings\n        ts_data_type = 'blessed'  # either 'blessed', 'unblessed', or 'ptdata'\n        # metric to use for core/edge binning (either 'psin' or 'rhovn')\n        ts_radius = 'rhovn'\n        # ts_radius value defining boundary of 'core' region (between 0 and 1)\n        ts_core_margin = 0.3\n        # ts_radius value defining inner and outer side of 'edge' region (between ts_core_margin and 1)\n        ts_edge_inner = 0.85\n        ts_edge_outer = 0.95\n        # All data outside this range excluded. For example, psin=0 at magnetic axis and 1 at separatrix.\n        ts_radial_range = (0, 1)\n        # set to true to interpolate ts_channel data onto equispaced radial grid\n        ts_equispaced = True\n        ###################################################\n\n        # Initialize arrays\n        te_core = np.full(len(self._times), np.nan)\n        ne_core = np.full(len(self._times), np.nan)\n        # Averaged over edge region\n        te_edge = np.full(len(self._times), np.nan)\n        ne_edge = np.full(len(self._times), np.nan)\n        # Averaged over 85th to 88th surface\n        te_edge_80to85 = np.full(len(self._times), np.nan)\n        ne_edge_80to85 = np.full(len(self._times), np.nan)\n        te_edge_85to90 = np.full(len(self._times), np.nan)\n        ne_edge_85to90 = np.full(len(self._times), np.nan)\n        te_edge_90to95 = np.full(len(self._times), np.nan)\n        ne_edge_90to95 = np.full(len(self._times), np.nan)\n        te_edge_95to100 = np.full(len(self._times), np.nan)\n        ne_edge_95to100 = np.full(len(self._times), np.nan)\n        # Separatrix\n        te_sep = np.full(len(self._times), np.nan)\n        ne_sep = np.full(len(self._times), np.nan)\n\n        # Try to get data via _get_ne_te()\n        try:\n            ts = self._get_ne_te()\n            efit_dict = self._get_efit_dict\n            ts['psin'], ts['rho_vn'] = efit_rz_interp(ts, efit_dict)\n        except Exception as e:\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            ts = 0\n        if ts == 0:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Both TS data missing for shot #{self._shot_id}\")\n        if ts != 0:\n            # Drop data outside of valid range #ADM: this looks unfinished\n            invalid_indices = np.where((ts[ts_radius] &lt; ts_radial_range[0]) | (\n                ts[ts_radius] &gt; ts_radial_range[1]))\n\n        # TODO: 1) Interpolate in core and edge regions, 2) compute average in these regions and store in respective array. Note that we may need to expand the available indices beyond 1\n\n        return pd.DataFrame({'te_core': te_core, 'ne_core': ne_core, 'te_core': te_edge, 'ne_edge': ne_edge, 'te_edge_80to85': te_edge_80to85, 'ne_edge_80to85': ne_edge_80to85,\n                             'te_edge_85to90': te_edge_85to90, 'ne_edge_85to90': ne_edge_85to90, 'te_edge_90to95': te_edge_90to95, 'ne_edge_90to95': ne_edge_90to95, 'te_edge_95to100': te_edge_95to100, 'ne_edge_95to100': ne_edge_95to100, 'te_sep': te_sep, 'ne_sep': ne_sep})\n\n    def get_zeff_parameters(self):\n        self.conn.openTree('d3d', self._shot_id)\n        # Get Zeff\n        try:\n            zeff = self.conn.get(\n                r'\\d3d::top.spectroscopy.vb.zeff:zeff').data()\n            # t_nbi = self.conn.get(\n            # r\"dim_of(\\d3d::top.nb:pinj)\").data()/1.e3  # [ms]-&gt;[s]\n            t_zeff = self.conn.get(\n                r'dim_of(\\d3d::top.spectroscopy.vb.zeff:zeff)').data()/1.e3  # [ms] -&gt; [s]\n            if len(t_zeff) &gt; 2:\n                zeff = interp1(t_zeff, zeff, self._times,\n                               'linear', bounds_error=False, fill_value=0.)\n            else:\n                zeff = np.zeros(len(self._times))\n                self.logger.info(\n                    f\"[Shot {self._shot_id}]:No zeff data found in this shot.\")\n        except MdsException as e:\n            zeff = np.zeros(len(self._times))\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to open Zeff node\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n        return pd.DataFrame({'z_eff': zeff})\n\n    def get_kappa_area(self):\n        self.conn.openTree(self.efit_tree_name, self._shot_id)\n        a_minor = self.conn.get(r'\\efit_a_eqdsk:aminor').data()\n        area = self.conn.get(r'\\efit_a_eqdsk:area').data()\n        chisq = self.conn.get(r'\\efit_a_eqdsk:chisq').data()\n        t = self.conn.get(r'\\efit_a_eqdsk:atime')\n        kappa_area = area / (np.pi * a_minor**2)\n        invalid_indices = np.where(chisq &gt; 50)\n        kappa_area[invalid_indices] = np.nan\n        kappa_area = interp1(t, kappa_area, self._times)\n        return pd.DataFrame({'kappa_area': kappa_area})\n\n    def get_h_parameters(self):\n        h98 = np.full(len(self._times), np.nan)\n        self.conn.openTree('transport', self._shot_id)\n        h98, t_h98 = self._get_signal(r'\\H_THH98Y2')\n        self.conn.openTree('d3d')\n        h_alpha, t_h_alpha = self._get_signal(r'\\fs04')\n        h98 = interp1(t_h98, h98, self._times)\n        h_alpha = interp1(t_h_alpha, h_alpha, self._times)\n        return pd.DataFrame({'H98': h98, 'H_alpha': h_alpha})\n\n    def get_shape_parameters(self):\n        self.conn.openTree(self.efit_tree_name, self._shot_id)\n        efit_time = self.conn.get(\n            r'\\efit_a_eqdsk:atime').data()/1.e3  # [ms] -&gt; [s]\n        sqfod = self.conn.get(r'\\efit_a_eqdsk:sqfod').data()\n        sqfou = self.conn.get(r'\\efit_a_eqdsk:sqfou').data()\n        tritop = self.conn.get(r'\\efit_a_eqdsk:tritop').data()  # meters\n        tribot = self.conn.get(r'\\efit_a_eqdsk:tribot').data()  # meters\n        # plasma minor radius [m]\n        aminor = self.conn.get(r'\\efit_a_eqdsk:aminor').data()\n        chisq = self.conn.get(r'\\efit_a_eqdsk:chisq').data()\n        # Compute triangularity and squareness:\n        delta = (tritop+tribot)/2.0\n        squareness = (sqfod+sqfou)/2.0\n\n        # Remove invalid indices\n        invalid_indices = np.where(chisq &gt; 50)\n        delta[invalid_indices] = np.nan\n        squareness[invalid_indices] = np.nan\n        aminor[invalid_indices] = np.nan\n\n        # Interpolate to desired times\n        delta = interp1(efit_time, delta, self._times, 'linear',\n                        bounds_error=False, fill_value=np.nan)\n        squareness = interp1(efit_time, squareness, self._times,\n                             'linear', bounds_error=False, fill_value=np.nan)\n        aminor = interp1(efit_time, aminor, self._times,\n                         'linear', bounds_error=False, fill_value=np.nan)\n        return pd.DataFrame({'delta': delta, 'squareness': squareness, 'aminor': aminor})\n\n    def _get_ne_te(self, data_source=\"unblessed\", ts_systems=['core', 'tangential']):\n        if data_source == 'blessed':  # 'blessed' by Thomson group\n            mds_path = r'\\top.ts.blessed.'\n        elif data_source == 'unblessed':\n            mds_path = r'\\top.ts.revisions.revision00.'\n        elif data_source == 'ptdata':\n            mds_path = r'\\top.ts.blessed.'  # Don't ask...I don't have the answer\n            raise NotImplementedError(\n                \"ptdata case not fully implemented yet\")  # TODO\n        else:\n            raise ValueError(f\"Invalid data_source: {data_source}\")\n        # Account for pointname formatting change in 2017 (however using ptdata is unimplemented)\n        suffix = {'core': 'cor', 'tangential': 'tan'}\n        if self._shot_id &lt; 172749:  # First shot on Sep 19, 2017\n            suffix['tangential'] = 'hor'\n        self.conn.openTree('electrons', self._shot_id)\n        lasers = dict()\n        for laser in ts_systems:\n            lasers[laser] = dict()\n            sub_tree = f\"{mds_path}{laser}\"\n            try:\n                # major radial position of measurement\n                lasers[laser]['r'] = self.conn.get(f\"{sub_tree}:r\").data()\n                # vertical position of measurement\n                lasers[laser]['z'] = self.conn.get(f\"{sub_tree}:z\").data()\n                # electron temperature\n                lasers[laser]['te'] = self.conn.get(\n                    f\"{sub_tree}:temp\").data()\n                lasers[laser]['ne'] = self.conn.get(\n                    f\"{sub_tree}:dens\").data()  # electron density\n                lasers[laser]['time'] = self.conn.get(\n                    f\"dim_of({sub_tree}:temp,0)\").data()/1.e3  # [ms] -&gt; [s]\n                # NOTE: These are absolute errors\n                # NOTE: Matlab scripts currently populate both errors with temperature error\n                lasers[laser]['te_error'] = self.conn.get(\n                    f\"{sub_tree}:temp_e\").data()\n                lasers[laser]['ne_error'] = self.conn.get(\n                    f\"{sub_tree}:density_e\").data()\n                # Place NaNs for broken channels\n                lasers[laser]['te'][np.where(\n                    lasers[laser]['te'] == 0)] = np.nan\n                lasers[laser]['ne'][np.where(\n                    lasers[laser]['ne'] == 0)] = np.nan\n            except MdsException as e:\n                lasers[laser] == None\n                self.logger.info(\n                    f\"[Shot {self._shot_id}]: Failed to get {laser} data\")\n                self.logger.debug(f\"[Shot {self._shot_id}]: {e}\")\n        # If both systems/lasers available, combine them and interpolate the data\n        # from the tangential system onto the finer (core) timebase\n        if 'tangential' in lasers and lasers['tangential'] is not None:\n            if 'core' in lasers and lasers['core'] is not None:\n                # Interpolate tangential data onto core timebase\n                for key in lasers['tangential']:\n                    if key != 'time':\n                        lasers['tangential'][key] = interp1(\n                            lasers['tangential']['time'], lasers['tangential'][key], lasers['core']['time'])\n                        lasers['combined'][key] = np.concatenate(\n                            lasers['core'][key], lasers['tangential'][key])\n                lasers['tangential']['time'] = lasers['core']['time']\n                lasers['combined']['time'] = lasers['core']['time']\n        return lasers\n\n    def _get_p_rad(self, fan='custom'):\n        if fan == 'upper':\n            fan_chans = np.arange(0, 24)\n        elif fan == 'lower':\n            fan_chans = np.arange(24, 48)\n        elif fan == 'custom':\n            # 1st choice (heavily cover divertor and core)\n            fan_chans = np.array(\n                [3, 4, 5, 6, 7, 8, 9, 12, 14, 15, 16, 22]) + 24\n\n        # Get bolometry data\n        self.conn.openTree(\"bolom\", self._shot_id)\n        bol_prm, _ = self._get_signal(r'\\bol_prm', interpolate=False)\n        lower_channels = [f\"bol_u{i+1:02d}_v\" for i in range(24)]\n        upper_channels = [f\"bol_l{i+1:02d}_v\" for i in range(24)]\n        bol_channels = lower_channels + upper_channels\n        bol_signals = []\n        bol_times = []\n        for i in range(48):\n            bol_signal, bol_time = self._get_signal(\n                fr\"\\top.raw:{bol_channels[i]}\", interpolate=False)\n            bol_signals.append(bol_signal)\n            bol_times.append(bol_time)\n        a_struct = get_bolo(self._shot_id, bol_channels,\n                            bol_prm, bol_signals, bol_times)\n        b_struct = power(a_struct)\n\n        # \"Sometimes the bolo data is garbage.\" Check the 'ier' flag and remove bad channels\n        self.conn.openTree(self.efit_tree_name, self._shot_id)\n        r_major_axis, efit_time = self._get_signal(\n            r'\\top.results.geqdsk:rmaxis', interpolate=False)\n        data_dict = {'ch_avail': [], 'z': [], 'brightness': [],\n                     'power': [], 'x': np.full((len(efit_time), len(fan_chans)), np.nan), 'xtime': efit_time, 't': a_struct.raw_time}\n        for i in range(len(fan_chans)):\n            chan = fan_chans[i]\n            data_dict['power'].append(b_struct.chan[chan].chanpwr)\n            if a_struct.channels[chan].ier == 0:\n                data_dict['ch_avail'].append(chan)\n            data_dict['x'][:, i] = a_struct.channels[chan].Z + \\\n                np.tan(a_struct.channels[chan].angle*np.pi/180.0) * \\\n                (r_major_axis - a_struct.channels[chan].R)\n            b_struct.chan[chan].chanpwr[np.where(\n                b_struct.chan[chan].chanpwr &lt; 0)] = 0\n            b_struct.chan[chan].brightness[np.where(\n                b_struct.chan[chan].brightness &lt; 0)] = 0\n            data_dict['z'].append(b_struct.chan[i].chanpwr)\n            data_dict['brightness'].append(b_struct.chan[i].brightness)\n        return data_dict\n\n    # TODO: Replace all instances of efit_dict with a dataclass\n    def _get_efit_dict(self):\n        self.conn.openTree(self.efit_tree_name, self._shot_id)\n        efit_dict = dict()\n        path = r'\\top.results.geqdsk:'\n        efit_dict['time'] = self.conn.get(\n            f\"dim_of({path}psirz,2)\").data()/1.e3  # [ms] -&gt; [s]\n        efit_dict['z'] = self.conn.get(f\"{path}z\").data()\n        efit_dict['r'] = self.conn.get(f\"{path}r\").data()\n        efit_dict['rho_vn'] = self.conn.get(f\"{path}rho_vn\").data()\n        efit_dict['psirz'] = self.conn.get(f\"{path}psirz\").data()\n        efit_dict['zmaxis'] = self.conn.get(f\"{path}zmaxis\").data()\n        return efit_dict\n</code></pre>"},{"location":"shots-reference/#disruption_py.shots.d3d_shot.D3DShot.get_z_parameters","title":"<code>get_z_parameters()</code>","text":"<p>On DIII-D the plasma control system uses isoflux control to control the plasma shape and position.  It does NOT use zcur control.  Therefore, the PCS does not have a programmed vertical position.  This this routine will now always return an arrays of NaN for z_prog, z_error, and z_error_norm.</p> Source code in <code>disruption_py\\shots\\d3d_shot.py</code> <pre><code>def get_z_parameters(self):\n\"\"\"\n    On DIII-D the plasma control system uses isoflux\n    control to control the plasma shape and position.  It does\n    NOT use zcur control.  Therefore, the PCS does not have a\n    programmed vertical position.  This this routine will now\n    always return an arrays of NaN for z_prog, z_error, and\n    z_error_norm.\n    \"\"\"\n    z_cur = np.full(len(self._times), np.nan)\n    z_cur_norm = np.full(len(self._times), np.nan)\n    z_prog = np.full(len(self._times), np.nan)\n    z_error = np.full(len(self._times), np.nan)\n    z_error_norm = np.full(len(self._times), np.nan)\n    self.conn.openTree('d3d', self._shot_id)\n    try:\n        t_z_cur = self.conn.get(\n            f\"dim_of(ptdata('vpszp', {self._shot_id}))\").data()/1.e3  # [ms] -&gt; [s]\n        z_cur = self.conn.get(\n            f\"ptdata('vpszp', {self._shot_id})\").data()/1.e2  # [cm] -&gt; [m]\n        z_cur = interp1(t_z_cur, z_cur, self._times, 'linear')\n        self.conn.openTree(self.efit_tree_name, self._shot_id)\n        try:\n            t_a = self.conn.get(\n                r'\\efit_a_eqdsk:atime').data()/1.e3  # [ms] -&gt; [s]\n            a_minor = self.conn.get(r'\\efit_a_eqdsk:aminor').data()  # [m]\n            chisq = self.conn.get(r'\\efit_a_eqdsk:chisq').data()\n            invalid_indices = np.where(chisq &gt; 50)\n            a_minor[invalid_indices] = np.nan\n            a_minor = interp1(t_a, a_minor, self._times, 'linear')\n            z_cur_norm = z_cur/a_minor\n        except MdsException as e:\n            self.logger.info(\n                f\"[Shot {self._shot_id}]:Failed to get efit parameters\")\n            self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n            z_cur_norm = z_cur / self.nominal_flattop_radius\n    except MdsException as e:\n        self.logger.info(\n            f\"[Shot {self._shot_id}]:Failed to get vpszp signal\")\n        self.logger.debug(f\"[Shot {self._shot_id}]:{e}\")\n    return pd.DataFrame({'zcur': z_cur, 'zcur_normalized': z_cur_norm, 'z_prog': z_prog, 'z_error': z_error, 'z_error_normalized': z_error_norm})\n</code></pre>"}]}