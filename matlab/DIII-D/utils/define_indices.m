if (exist('ip','var')==0 || ...
    exist('ip_error','var')==0 || ...
    exist('time_until_disrupt','var')==0 || ...
    exist('time','var')==0 || ...
    exist('shot','var')==0 || ...
    exist('dipprog_dt','var') ==0 || ...
    exist('intentional_disruption','var') ==0 || ...
    exist('other_hardware_failure','var') ==0 || ...
    exist('power_supply_railed','var')==0);
  fprintf(1,['You must read in the following variables from the\n' ...
             'disruption warning database:\n' ...
             ' ''shot'', ''time'', ''time_until_disrupt'',' ...
             ' ''ip'', ''ip_error'', ' ...
             ' ''dipprog_dt'', \n ''power_supply_railed'',' ...
             ' ''intentional_disruption'', ''other_hardware_failure''\n' ...
             'or call ''retrieve_all_params'' before\n' ...
             'calling this routine.\n']);
  return;
end;

% For determination of the flattop portion of some shots, we will need to
% have the programmed Ip signal.  But this is not stored in our disruption
% warning database.  However, we can reconstruct it by taking the
% difference between ip and ip_error.  Note that this 'ip_prog' has the
% same polarity as 'ip', unlike that actual 'iptipp' signal in the point
% data.

ip_prog = ip - ip_error;

indices_no_disrupt = find(isnan(time_until_disrupt));
indices_disrupt = find(~isnan(time_until_disrupt));
indices_flattop = find(abs(dipprog_dt) <= 2.e3 & ...  % 2 kA/s limit
  abs(ip_prog) > 100e3 & ...
  intentional_disruption ~= 1 & ...
  other_hardware_failure ~= 1 & ...
  power_supply_railed ~= 1);
indices_disrupt_time = find(time_until_disrupt == 0);
indices_disrupt_time_in_flattop = ...
  intersect(indices_disrupt_time, indices_flattop);
indices_disrupt_in_flattop = ...
  find(ismember(shot, shot(indices_disrupt_time_in_flattop)));
indices_flattop_disrupt_in_flattop = ...
  intersect(indices_flattop, indices_disrupt_in_flattop);
indices_flattop_no_disrupt = ...
  intersect(indices_flattop, indices_no_disrupt);
